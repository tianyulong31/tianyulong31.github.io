[{"title":"C语言核心内容总结","path":"/2025/10/25/C语言核心内容总结/","content":"距离学完C语言核心内容已过半月、是时候总结一下我的学习成果了，在过去的半月中、曾一度面对困难想要逃避放弃，但积累的成果告诉我，我已经做了这么多了，那些曾经棘手的问题都已经转换成了我积累的一部分了。 C语言核心内容笔记 核心关键字32 个关键字auto break case char const continue default dodouble else enum extern float for goto ifint long register return short signed sizeof staticstruct switch typedef union unsigned void volatile while 第一档 ：int 整型类型关键字，声明整数变量、函数返回值。return 函数返回语句，结束函数并带回结果。if （else） 条件判断for 计数循环最常用。while 条件循环。break 跳出当前循环或switch。continue 跳过本轮循环剩余语句。switch 多路分支。case switch 的分支标签。default 处理switch中为被case标签匹配的情况。void “空”类型，函数不返回值或指针不带类型。sizeof 编译期求类型对象字节数 第二档：char 字符／最小整数类型。float 单精度浮点。double 双精度浮点。long 加长整型short 短整型。signed unsigned 有符号／无符号修饰符。const 只读修饰符，编译期阻止修改。static 两种用法： 1. 函数内部——静态存储期，只初始化一次。 2. 函数文件外部——内部链接，只对当前文件可见。extern 声明标识符“定义在别处”，跨文件引用全局变量函数。struct 结构体，聚合类型之王。union 联合体，同一内存 overlay 多种类型。enum 枚举，给整型常量起名字。typedef 给已有类型起新名字，造“别名”。volatile 告诉编译器“该对象可能异步改变”，禁止优化。 第三档auto 函数内局部变量默认就是 auto，写不写都一样。do do{…}while(); 循环，至少执行一次。goto 无条件跳转，能不用就不用。register 建议编译器把变量放寄存器，现代编译器基本忽略。 内存管理学习c语言一定要联系计算机背后的运行逻辑，而其与计算机中的内存管理最为重要 保留区作用捕获“空指针解引用”和“小偏移量野指针”为内核 vsyscall、vsyscall32、vdso 等保留固定映射页属性：不可访问 代码段内容： – 所写的函数体、编译器生成的辅助函数。 – 模块初始化函数（**init）在 Linux 内核被收集到 .init.text，启动完后内核会把这块回收。属性：可读可执行，不可写。生命周期：随进程一直存在；内核模块的 .init.text 在初始化结束被 free_init_pages() 释放。 数据段rodata编译器把字符串、跳转表等单独放进 .rodata，只读数据段防止映射成可执行页。内容：字符串字面量、const 全局变量、switch 跳转表、printk 的格式串…… 已初始化数据段Data内容： – 全局变量、文件作用域变量、static 局部变量，且你在源码里给了初值。 – 内核的 **initdata，启动后同样会被回收。属性：可读可写，不可执行。 未初始化数据段BSS内容：全局static 变量未显式赋初值（或初值为 0）属性：可读可写，不可执行。 堆内容：malloccallocnew、realloc、free 管理的对象；内核的 kmalloc(vmalloc) 区。增长方向：向高地址伸展。属性：可读可写，可执行堆需显示（高危操作）。生命周期：程序员显式释放或进程退出时内核统一回收。 栈内容： – 函数调用的返回地址、参数、局部变量、寄存器保存区。 – 编译器生成的临时数组、VLAs、alloca()。内容：增长方向：向低地址生长属性：可读可写，不可执行。生命周期：线程创建时分配，线程退出时回收；主线程随进程一起消失。 动态内存管理malloc、calloc都是向“堆（heap）”申请一块连续内存的标准库函数，不会被自动回收，需要手动释放。本身属于 libc 的 text（代码段）；它们返回的那块空间才属于 heap（堆）。 #include stdlib.hvoid *malloc(size_t size); // 申请 size 字节，内容不确定void *calloc(number, size_t size); // 申请 number 块，每块size字节 ，全部清 0//返回值：成功返回指向首字节的 void * ，失败返回 NULL 。所以必须做 NULL 检查！ calloc与malloc的优缺点：1.calloc 内部会检测 number*size 是否溢出；而 malloc 不会，使用malloc必须做溢出处理。2.申请大块内存 calloc会把每一页刷成 0，所以比malloc慢。如果随后需要自己再写一遍，不如直接 malloc +手动赋初值。3.无论是 malloc 还是 calloc ，都必须用 free(ptr) 释放一次且仅一次。 memsetmemset 是 C 标准库 string.h 里最常用的“内存填充”工具函数把从地址a开始的n个字节，全部设置为同一个字节值b。 #include string.hvoid *memset(void *a, int b, size_t n); memset的典型用法1.清零 int a[100];memset(a, 0, sizeof a); // 整个数组变 0 2.置1字节 unsigned char buf[64];memset(buf, 0xFF, sizeof buf); // 每个字节 0xFF 3.初始化为某个字节 char str[32];memset(str, *, sizeof str - 1);/* 31 个 * */str[31] = \\0; // 手动补字符串结束符 、 错误处理防御性编程定义：种主动预防错误的编程策略，强调在代码中提前识别并处理潜在问题，避免因外部输入、异常状态或并发操作导致系统崩溃核心假设 ：输入总是错误的- 外部依赖不可靠- 代码本身可能有 bug目标 ：提高系统的健壮性、可维护性、容错能力，降低故障蔓延风险。 Segmentation（段错误） 根本原因：访问了无权或无效的虚拟地址1.解印引用NULL2.野指针悬垂指针3.越界访问4.缓冲区溢出覆盖返回地址5.对字符串常量区写入6.函数返回局部变量地址 总结学习c语言没有完成时，只有提高我们的逻辑思维不断的增加c语言相关知识，才能够编程出更精简更出色的代码。学习了c语言的知识就该知道如何使用它们，在使用的过程中接触新的内容，融会贯通，才能在编程的道路上越走越。"},{"title":"使用c语言创建顺序表","path":"/2025/10/22/顺序表的创建/","content":"本篇文章是我学习数据结构过程中，共花费4个小时实现顺序表创建的c语言代码，学完c语言后第一次完全由自己从零到一写完代码的过程，在学习过程中总会遇到当前阶段难以挑战的困难，我也在学习数据结构的过程中几次逃避，但是‘积累’给我带来面对挑战的勇气，长期的积累就是我不服输的底气。 代码展示// 引入3个头文件：布尔类型、通用工具、标准输入输出#include stdbool.h#include stdlib.h#include stdio.htypedef int DataType_t; //可替换数据类型/* 顺序表结构体定义 */typedef struct SequenceList int * Addr; // 指向真正存放数据的动态数组 unsigned int MaxSize; // 数组最大容量 int Last; // 当前最后一个元素的下标（空表时为-1） SeqList_t;/* 创建一个容量为size的顺序表，返回管理体指针 */SeqList_t * SeqList_Create(unsigned DataType_t size) // 给管理体本身申请一块清零的内存 SeqList_t *Manager = (SeqList_t *)calloc(1, sizeof(SeqList_t)); if (NULL == Manager) // 管理体内存申请失败 printf(为管理体分配内存失败 ); exit(-1); // 直接终止整个程序 if (0 = size) // 容量不合法 printf(创建的顺序表尺寸不能小于1 ); exit(-1); // 给数据区申请size个int的清零空间 Manager-Addr = (DataType_t *)calloc(size, sizeof(int)); if (NULL == Manager-Addr) // 数据区内存申请失败 printf(为管理体指向Addr的储存区分配内存失败 ); free(Manager); // 先释放已申请的管理体 exit(-1); Manager-MaxSize = size; // 记录最大容量 Manager-Last = -1; // 初始为空表 return Manager; // 返回管理体指针/* 判断顺序表是否已满 */bool SeqList_IsFull(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last + 1 == Manager-MaxSize); // 满返回true，否则false/* 判断顺序表是否为空 */bool SeqList_IsEmpty(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last == -1); // Last为-1表示空表/* 头插：把data插入到表头（下标0位置） */bool SeqList_HeadAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; // 把原有元素整体后移一位 for (int i = Manager-Last; i = 0; --i) Manager-Addr[i + 1] = Manager-Addr[i]; Manager-Addr[0] = data; // 新元素放入头部 Manager-Last++; // 更新Last return true;/* 尾插：把data追加到表尾 */bool SeqList_TailAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; Manager-Addr[++Manager-Last] = data; // 先Last+1，再写入数据 return true;/* 按值删除：删除第一个等于data的元素 */bool SeqList_Del(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表无法删除 printf(顺序表为空，无法删除 ); return false; int i = 0; // 找到第一个等于data的元素下标 while (Manager-Addr[i] != data i = Manager-Last) i++; if (i = Manager-Last) // 找到了 // 把后面元素整体前移一位覆盖掉被删元素 while (i Manager-Last) Manager-Addr[i] = Manager-Addr[i + 1]; i++; Manager-Last--; // 元素个数减1 return true; // 没找到 printf(此顺序表中没有找到你指定要删除的数 ); return false;/* 打印整个顺序表 */bool SeqList_Print(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表提示 printf(元素为空无法打印 ); return false; // 逐个元素打印 for (int i = 0; i = Manager-Last; ++i) printf(Addr[%d]=%d , i, Manager-Addr[i]); return true;/* 销毁顺序表：先释放数据区，再释放管理体 */void SeqList_Destroy(SeqList_t *Manager) if (!Manager) return; // 空指针直接返回 free(Manager-Addr); // 释放数据区 free(Manager); // 释放管理体/* 主函数：简单测试 */int main(int argc, char const *argv[]) // 创建一个容量为5的顺序表 SeqList_t *list = SeqList_Create(5); // 尾插5个元素 SeqList_TailAdd(list, 10); SeqList_TailAdd(list, 20); SeqList_TailAdd(list, 30); SeqList_TailAdd(list, 40); SeqList_TailAdd(list, 50); SeqList_Print(list); // 打印当前表 printf( ); // 删除3个元素 SeqList_Del(list, 10); SeqList_Del(list, 30); SeqList_Del(list, 50); SeqList_Print(list); // 再次打印 SeqList_Destroy(list); // 用完销毁 return 0; 当然作为一个初学者我所写的代码还存在着可以优化的地方，但从逻辑上来分析我所写代码的优势就在于逻辑清晰。放在学生作业、嵌入式底层库中、面试笔试场景中都有不少亮点。 代码优势1.结构设计： 我将管理元数据与数据区彻底分离。2.接口语义清晰： 我大部分函数都使用的bool返回，失败false、成功true，语义单一。3.可裁剪性高： 没有任何全局变量静态变量。4.精确的错误信息： 每条错误都带由中文提示。5.空指针的保护密度： 每个接口都做了 if (!Manager) return false;。6.初始化策略： 选择使用calloc，使用malloc需要手动添加memset。7.数据类型： 可以更改数据类型，提高了泛型能力。 代码缺点 内存申请失败直接 exit，把库变成了进程杀手，嵌入式或插件场景根本没法优雅降级。 容量固定，没有扩容接口，浪费内存。 头插和删除用循环搬数据，O(n) 最坏复杂度。 按值删除只清掉第一个匹配项，想全删得外层再套循环，时间平方级。 只有头插尾插，没有按位置插入，用户想往中间放元素只能自己拼“删了再插”的野路子，还是 O(n²)。 没有 FindIndexOf 这类只读定位，判断存在性只能裸翻内存或打印人肉搜索，封装性被击穿。"},{"title":"2025年9月-10月总结","path":"/2025/10/18/2025年9月-10月总结/","content":"这是我2025年至2026年的规划，截至至2025年10月18日我已经学完了c语言，预计至10月25日学完嵌入式该具备的数据结构知识。为应对软件考试：嵌入式系统设计师，我也在阅读《嵌入式系统设计师教程》，预计明年报考。 c语言部分笔记展示 阅读《嵌入式系统设计师教程》部分笔记 深入学习了计算机的基础知识，计算机的包括组成结构，运行逻辑以及原理。对计算机的重要部件进行了研究。 数据结构部分笔记展示 数据结构与c语言紧密结合，既有对c语言代码运行的底层逻辑，对程序运行中涉及到的各个器件、内存都必须要有深刻的了解。 总结 这是我的第一篇博客，今后我会将我的各个阶段的总结、成果、笔记上传至此博客，既是对我个人的积累，也是希望我所分享的内容能为他人带来帮助。"}]