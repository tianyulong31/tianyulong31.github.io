[{"title":"计算机系统基础知识","path":"/2025/10/26/嵌入式系统设计师第一章/","content":"这是我阅读《嵌入式系统设计师》第一章所写的笔记以及知识概要，第一章讲的是计算机的基础知识，涉及的到了计算机各种器件、系统包括底层逻辑。 嵌入式计算机系统概述计算机硬件嵌入式计算机是以应用为中心，以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。 计算机硬件系统由运算器、控制器、储存器、输入设备、输出设备组成。 运算器和控制器以及相关部件集成一起称为中央处理单元：cpu。 运算器：对数据进行加工处理。 控制器：从主存取出指令进行分析。 储存器：分为内存（掉电丢失）、外存（掉电不丢失）。寄存器是cpu中的储存器件（储存少量数据，读取速度更快。） 数据表示进制转换 效验码 奇偶校验码 海明码在数据之间的特定位置插入k个校验位，通过扩大码距实现验错和纠错。 异或运算计算方式 算数运算计算机使用加法运算器，将两个数的补码相加。加上一个负数时，二进制数超过八位则自然丢弃。 溢出及判定两个补码相加时有可能会向第八位进1，但第八位是符号位，俩正数相加不可能得出负数。双符号位判决法、进位判决法 计算机组成及主要部件CPU的功能：程序控制、操作控制、时间控制、数据处理。CPU还会对系统内部和外部的中断（异常）做出响应。CPU构造图 运算器：算术逻辑单元、累加寄存器、数据缓存寄存器、状态条件寄存器组成。 控制器发出信号控制运算器。运算器不会自己产生程序。 算术逻辑单元（ALU）：处理数据对进行算术和逻辑运算。 累加寄存器（AC）：ALU的工作区“默认操作数和结果暂存桌”，减少CPU多次访问内存。 数据缓冲寄存器（DR）：暂时作为CPU与内存、外部设备数据传输之间的中转站，只能存一条指令或一个数据字。 状态条件寄存器（PSW）：存结果为零有进位溢出的状态，让 CPU 知道下一步该不该跳转。 控制器：指令控制逻辑、时序控制逻辑、中断控制逻辑。 指令控制逻辑：取指令、分析指令、执行指令。 指令寄存器（IR）：CPU将要执行的指令，从内存到数据缓冲寄存器，再到IR暂存，由指令译码器根据IR的内容产生各种微操作的指令，控制其他组件。 程序计数器（PC）：寄存信息和计数。 地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。 指令译码器（ID）：指令包含操作码和地址码，ID对操作码进行分析，识别该指令的规定操作。 时序控制逻辑：为每条指令按时间提供控制信息。总线逻辑是为多个功能部件服务信息通路的控制电路。中断控制逻辑用于控制各种中断请求，并根据优先级的高低对中断请求进行排队。 运算器和控制器中的寄存器都是专用寄存器。 储存器高速缓存Cache（容量小，贵，掉电丢失）：储存内存中CPU可能需要的数据，加快CPU运行时间。Cache地址影像为主存中CPU需要的数据提前找好座位。直接映像：主存中和Cache中的块对应关系是固定的。全相联映像：主存中任何一块数据都能放进Cache中的任意一个空位。组相联映像：分组时直接映像，组内全相联映像。虚拟储存器：对主存的抽象，MMU实现虚拟地址到物理地址的转换。外存储器：磁盘、光盘、固态。储存域网络：连接服务器与储存设备的网络。 总线计算机中的总线是指计算机设备和设备之间传输信息的公共数据通道。数据总线：双向传输数据。地址总线：单向传递CPU发出的地址信息。地址总线的宽度决定CPU的最大寻址能力控制总线：传输控制信号、时序信号、状态信号 南北桥芯片结构北桥芯片直接与CPU（通过前端总线）、内存（内存总线）、显卡（IO总线）、南桥相连，控制CPU的类型、主板的总线频率、内存控制器、显示核心等。南桥芯片：负责外部设备接口与内部CPU的联系（IO总线），如USB、ATA、SATA以及扩展接口。（包含多种设备的控制器、硬盘控制器、USB控制器、网卡、声卡控制器） 单芯片结构取消了北桥，CPU内置内存控制器，提高频率减少延迟。 常见总线ISA总线、EISA总线、PCI总线（其工作与CPU相互独立，PCI总线时钟与CPU时钟也是相互独立，PCI总线上的设备可以申请成为主控设备，与从属设备进行点对点的数据传输。还能对传输的地址和信号进行奇偶校验检测。 输入输出控制IO设备：电子芯片、导线、电源、电子控制设备、电机等组成的物理设备。 IO设备可分为块设备（将信息存放于独立的块中，可寻址，包括磁盘、USB闪存等）、字符设备（以字符为单位接收或发送一个字符串，不可寻址，包括打印机、网卡、鼠标键盘等） 设备控制器都有几个寄存器与CPU进行通信（通过寄存器发送或接收数据，和了解设备的状态）寄存器数量和大小有限，一般会RAM性质的缓冲区来存放数据。 RAM（随机存储器、主存、内存）：断电丢失数据、高速存取、随机访问、临时存储。 CPU如何与设备控制器中寄存器和数据缓冲区进行通信：1.\t为每个控制器分配一个IO端口，形成端口空间，并将信息储存于内存，由操作系统通过特殊指令和端口号来访问设备读取或是写入数据。2.\t将控制器的寄存器映射到内存空间，每个设备都有唯一的地址——内存映射IO。不需要特殊指令控制，可以使用C语言来编程。 程序控制方式无条件传送：外设无条件向CPU接收或发送数据。程序查询方式：通过CPU执行程序来查询外设的状态。 中断方式多中断信号线法：每个中断源都有属于自己的一根中断请求向CPU提供中断请求。 中断软件查询法：当CPU检测到了中断请求，立即转入中断服务程序去轮询每个中断源确实来源，对各个设备的相应由软件设定。 菊花链法：硬件查询法，所有IO模块共有一根共同的中断请求线，中断确认信号以链式在各个模块间相连，当CPU检测到中断请求信号时，则发出中断确认信号，中断确认信号依次在IO模块中传递，知道发出请求的模块，该模块把它的ID送往数据线由CPU读取。 总线仲裁法：一个IO设备在发出中断请求前，必须获得总线控制权，由总线仲裁来裁定谁可以发出中断请求信号，当CPU发出中断响应信号后该设备立即把自己的ID发往数据线。 DMA方式直接内存存取数据在内存与IO设备之间的直接成块传送，传输数据过程中不需要CPU干涉，CPU只需要发出开始或结束。DMA传送过程中，整个系统总线完全交给了DMAC，CPU不再使用总线。 输入输出处理机DMA出现方式减轻了CPU对IO操作的控制，使CPU效率提高。通道是是一个具有特殊功能的处理器，它分担一部分CPU功能，可以实现对外围设备的统一管理，完成外围设备与主存之间的数据传送。外围处理机，PPU是专用处理机，根据主机IO命令。完成对外设数据的输入输出 计算机体系结构计算机体系结构概述阿姆达尔：程序员要能编写出可以在机器上正确运行的程序必须了解概念性结构和功能特性。 梅尔斯：硬件与软件之间的界面，指令集体结构。 拜尔：体系结构由：结构（硬件互连）、组织（各种部件的动态联系与管理）、实现（各模块设计的组装完成）、性能（计算机系统的行为表现）。 计算机体系结构：计算机的概念性结构和功能特性。 计算机组织：计算机体系结构的逻辑实现，包括计算机内的数据流和控制流的组成以及逻辑设计。 计算机实现：计算机组织的物理实现。 计算机体系结构分类宏观：单处理系统、并行处理系统、多处理系统、分布式处理系统。 单处理系统：利用一个处理单元与外部设备结合实现储存、计算、通信、输入与输出等功能。 并行处理系统与多处理系统：将两个以上的处理器连接，协调通信，共同求解问题的计算机系统。 分布式处理系统：物理距离上远距离松耦合的多计算机系统。 微观（并行程度分类）：Flynn分类法、冯泽云分类法、Handler分类法、Kuck分类法 Flynn分类法：按指令流和数据流进行分类。单指令流、单数据流；单指令流、多数据流；多指令流、单数据流；多指令流、多数据流。 冯泽云分类法：按并行度（单位时间内处理的最大二进制位数）对计算机的系统进行结构分类。字串行位串行、字并行位串行、字串行位并行、字并行位并行 Handler分类法：基于硬件并行程度计算并行度的方法。 Kuck分类法：用指令流和执行流及其多重要性。类似于Flynn分类法 指令系统指令集体系结构：一个处理器支持的指令和指令的字节级编程。（不同处理器往往不通用） 指令集体系结构分类根据：操作数在CPU上的储存方式、显示操作数的数量、操作数的位置、指令的操作、操作数的类型与大小。 按暂存机制分类可将指令集体系分为：堆栈、累加器、寄存器组。 通用寄存器：寄存器提供更灵活的次序，能够储存变量。 CISC和RISC复杂指令集计算机（CISC）：增强原有指令的功能，用更复杂的新指令替换原先由软件程序完成的功能。 弊端：1.\t指令集过于庞杂。2.\t需要用多个CPU周期运行解释性微程序来执行复杂指令。3.\t高级语言编程程序选择目标指令范围很大，难以优化。4.\tCISC强调完善的中断控制，导致动作繁多、设计复杂、研制周期长。5.\tCISC增大芯片种类、出错率提高，成品率降低，成本提高。 精简指令集（RISC）：减少指令总数和简化指令功能、降低硬件设计复杂度，优化编译提高指令执行速度，采用硬布线控制逻辑优化编译程序。 RISC关键技术：1.\t重叠寄存器窗口技术：在处理器中设置数量较大的寄存器堆。2.\t优化编译技术：RISC使用大量寄存器，通过编译技术的优化来实现合理分配寄存器，提高寄存器的效率减少访存次数。3.\t超流水及超标量技术：进一步提高流水线速度。4.\t硬布线逻辑和微程序相结合在微程序技术中。 优化静态使用频率：对程序中出现的各种指令以及指令串进行统计得到的百分比。 按静态使用频率来改进目标代码，可减少程序所占的储存空间。 动态使用频率：在程序执行过程中各种指令以及指令串进行统计得到的百分比。 按动态是使用频率来改进目标代码，可减少程序运行的执行时间。 面向高级程序语言的优化思路是减少高级语言与机器语言之间的语义差距。 面向操作系统的优化思路是减少操作系统与体系结构之间的语义差距。 指令的流水处理指令控制方式：顺序方式、重叠方式、流水方式。 顺序方式：各条机器指令包括内部微操作按顺序串行执行，缺点速度慢、机器各部件利用率低。 重叠方式：在执行第K条指令就开始分析第K+1条指令。速度提高、易冲突。 流水方式：并行性或并发性嵌入计算机的一种形式。将重复的顺序处理过程分解为若干字过程，每个字过程都能在专用模块上有效的并发工作。 如分为取指令、指令译码、取操作数、执行，将机器指令并发在这几种模块上处理。1.\t级别：部件级、处理机级、系统级。2.\t功能：单功能流水、多功能流水。3.\t连接：静态流水线、多功能流水线。4.\t反馈回路：线性流水线、非线性流水线。5.\t流动顺序：同步流水线、异步流水线。6.\t数据：标量流水线、向量流水线。 流水的相关处理：对同一寄存器先写后读会出现指令相关、访存操作数相关、通用寄存组相关等，影响相关的两条或几条指令，也被称为局部相关。 推后法：推后相关单元的读，直至写入完成。 通路法：设置相关专用通路，先把运算结果写入相关储存单元。 全局性相关：不能同时解释转移指令，执行转移指令，可能会改变指令缓冲器中预取到指令内容，造成流水线的吞吐率（单位时间内流水线处理机流出的结果数）和效率下降。 猜测转移分支、加快和提前形成条件码、加快短循环程序的处理 RISC采用的流水技术超流水线：增加级数提高主频，以时间换空间。CPI（指令需要的机器周期数稍高。超标量技术：内装多条流水线同时执行多个处理，以空间换时间。超长指令字技术：充分发挥软件作用，使硬件简化，性能提高，需要足够高的时钟频率 阵列处理机、并行处理机、多处理机 可靠性与系统性能评测基础知识元器件可靠性的三个阶段开始阶段：不稳定失效率较高。第二阶段：正常工作期。第三阶段：老化期 计算机的可用性用正常工作的概率A表示 两次故障之间系统能正常工作时间的平均值MTBF 计算机的可维修性平均维修时间MTRF AMTBFMTBF+MTRF 计算机的RAS：可靠性R、可用性A、可维修性S 计算机可靠性模型 N模冗余系统：由N个（2n+1）相同的子系统和一个表决器组成，以N个系统中的多数输出作为系统输出. 提高计算机的可靠性1.\t提高元器件质量，改进加工工艺与工艺结构，完善电路设计。2.\t发展容错技术，使计算机在有故障的情况下依旧能工作。 计算机系统的性能评价性能评测的常用方法：时钟频率、指令执行速度、等效指令速度法、数据处理速率、核心程序法。 准测试程序整数测试程序：测试编译器、CPU处理整数指令、控制功能的有效性。 浮点测试程序：测试浮点计算能力。 1.理论峰值浮点速度（MFLOPS）：测试机器在理论上最大能完成的浮点计算速度。 2.Linpack基准测试程序：让机器运行Linpack程序来测量MFLOPS。 3.Whetstone基准测试程序：执行浮点运算、整数算术运算、功能调用、数组变址、条件转移和超越函数的程序组成。 SPEC基准程序：被测计算机的执行时间标准化，被测计算机的执行时间除以一个参考处理器的执行时间。 TPC基准程序：衡量机器性能以及性能价格比。"},{"title":"C语言核心内容总结","path":"/2025/10/25/C语言核心内容总结/","content":"距离学完C语言核心内容已过半月、是时候总结一下我的学习成果了，在过去的半月中、曾一度面对困难想要逃避放弃，但积累的成果告诉我，我已经做了这么多了，那些曾经棘手的问题都已经转换成了我积累的一部分了。 C语言核心内容笔记 核心关键字32 个关键字auto break case char const continue default dodouble else enum extern float for goto ifint long register return short signed sizeof staticstruct switch typedef union unsigned void volatile while 第一档 ：int 整型类型关键字，声明整数变量、函数返回值。return 函数返回语句，结束函数并带回结果。if （else） 条件判断for 计数循环最常用。while 条件循环。break 跳出当前循环或switch。continue 跳过本轮循环剩余语句。switch 多路分支。case switch 的分支标签。default 处理switch中为被case标签匹配的情况。void “空”类型，函数不返回值或指针不带类型。sizeof 编译期求类型对象字节数 第二档：char 字符／最小整数类型。float 单精度浮点。double 双精度浮点。long 加长整型short 短整型。signed unsigned 有符号／无符号修饰符。const 只读修饰符，编译期阻止修改。static 两种用法： 1. 函数内部——静态存储期，只初始化一次。 2. 函数文件外部——内部链接，只对当前文件可见。extern 声明标识符“定义在别处”，跨文件引用全局变量函数。struct 结构体，聚合类型之王。union 联合体，同一内存 overlay 多种类型。enum 枚举，给整型常量起名字。typedef 给已有类型起新名字，造“别名”。volatile 告诉编译器“该对象可能异步改变”，禁止优化。 第三档auto 函数内局部变量默认就是 auto，写不写都一样。do do{…}while(); 循环，至少执行一次。goto 无条件跳转，能不用就不用。register 建议编译器把变量放寄存器，现代编译器基本忽略。 内存管理学习c语言一定要联系计算机背后的运行逻辑，而其与计算机中的内存管理最为重要 保留区作用捕获“空指针解引用”和“小偏移量野指针”为内核 vsyscall、vsyscall32、vdso 等保留固定映射页属性：不可访问 代码段内容： – 所写的函数体、编译器生成的辅助函数。 – 模块初始化函数（**init）在 Linux 内核被收集到 .init.text，启动完后内核会把这块回收。属性：可读可执行，不可写。生命周期：随进程一直存在；内核模块的 .init.text 在初始化结束被 free_init_pages() 释放。 数据段rodata编译器把字符串、跳转表等单独放进 .rodata，只读数据段防止映射成可执行页。内容：字符串字面量、const 全局变量、switch 跳转表、printk 的格式串…… 已初始化数据段Data内容： – 全局变量、文件作用域变量、static 局部变量，且你在源码里给了初值。 – 内核的 **initdata，启动后同样会被回收。属性：可读可写，不可执行。 未初始化数据段BSS内容：全局static 变量未显式赋初值（或初值为 0）属性：可读可写，不可执行。 堆内容：malloccallocnew、realloc、free 管理的对象；内核的 kmalloc(vmalloc) 区。增长方向：向高地址伸展。属性：可读可写，可执行堆需显示（高危操作）。生命周期：程序员显式释放或进程退出时内核统一回收。 栈内容： – 函数调用的返回地址、参数、局部变量、寄存器保存区。 – 编译器生成的临时数组、VLAs、alloca()。内容：增长方向：向低地址生长属性：可读可写，不可执行。生命周期：线程创建时分配，线程退出时回收；主线程随进程一起消失。 动态内存管理malloc、calloc都是向“堆（heap）”申请一块连续内存的标准库函数，不会被自动回收，需要手动释放。本身属于 libc 的 text（代码段）；它们返回的那块空间才属于 heap（堆）。 #include stdlib.hvoid *malloc(size_t size); // 申请 size 字节，内容不确定void *calloc(number, size_t size); // 申请 number 块，每块size字节 ，全部清 0//返回值：成功返回指向首字节的 void * ，失败返回 NULL 。所以必须做 NULL 检查！ calloc与malloc的优缺点：1.calloc 内部会检测 number*size 是否溢出；而 malloc 不会，使用malloc必须做溢出处理。2.申请大块内存 calloc会把每一页刷成 0，所以比malloc慢。如果随后需要自己再写一遍，不如直接 malloc +手动赋初值。3.无论是 malloc 还是 calloc ，都必须用 free(ptr) 释放一次且仅一次。 memsetmemset 是 C 标准库 string.h 里最常用的“内存填充”工具函数把从地址a开始的n个字节，全部设置为同一个字节值b。 #include string.hvoid *memset(void *a, int b, size_t n); memset的典型用法1.清零 int a[100];memset(a, 0, sizeof a); // 整个数组变 0 2.置1字节 unsigned char buf[64];memset(buf, 0xFF, sizeof buf); // 每个字节 0xFF 3.初始化为某个字节 char str[32];memset(str, *, sizeof str - 1);/* 31 个 * */str[31] = \\0; // 手动补字符串结束符 、 错误处理防御性编程定义：种主动预防错误的编程策略，强调在代码中提前识别并处理潜在问题，避免因外部输入、异常状态或并发操作导致系统崩溃核心假设 ：输入总是错误的- 外部依赖不可靠- 代码本身可能有 bug目标 ：提高系统的健壮性、可维护性、容错能力，降低故障蔓延风险。 Segmentation（段错误） 根本原因：访问了无权或无效的虚拟地址1.解印引用NULL2.野指针悬垂指针3.越界访问4.缓冲区溢出覆盖返回地址5.对字符串常量区写入6.函数返回局部变量地址 总结学习c语言没有完成时，只有提高我们的逻辑思维不断的增加c语言相关知识，才能够编程出更精简更出色的代码。学习了c语言的知识就该知道如何使用它们，在使用的过程中接触新的内容，融会贯通，才能在编程的道路上越走越。"},{"title":"使用c语言创建顺序表","path":"/2025/10/22/顺序表的创建/","content":"本篇文章是我学习数据结构过程中，共花费4个小时实现顺序表创建的c语言代码，学完c语言后第一次完全由自己从零到一写完代码的过程，在学习过程中总会遇到当前阶段难以挑战的困难，我也在学习数据结构的过程中几次逃避，但是‘积累’给我带来面对挑战的勇气，长期的积累就是我不服输的底气。 代码展示// 引入3个头文件：布尔类型、通用工具、标准输入输出#include stdbool.h#include stdlib.h#include stdio.htypedef int DataType_t; //可替换数据类型/* 顺序表结构体定义 */typedef struct SequenceList int * Addr; // 指向真正存放数据的动态数组 unsigned int MaxSize; // 数组最大容量 int Last; // 当前最后一个元素的下标（空表时为-1） SeqList_t;/* 创建一个容量为size的顺序表，返回管理体指针 */SeqList_t * SeqList_Create(unsigned DataType_t size) // 给管理体本身申请一块清零的内存 SeqList_t *Manager = (SeqList_t *)calloc(1, sizeof(SeqList_t)); if (NULL == Manager) // 管理体内存申请失败 printf(为管理体分配内存失败 ); exit(-1); // 直接终止整个程序 if (0 = size) // 容量不合法 printf(创建的顺序表尺寸不能小于1 ); exit(-1); // 给数据区申请size个int的清零空间 Manager-Addr = (DataType_t *)calloc(size, sizeof(int)); if (NULL == Manager-Addr) // 数据区内存申请失败 printf(为管理体指向Addr的储存区分配内存失败 ); free(Manager); // 先释放已申请的管理体 exit(-1); Manager-MaxSize = size; // 记录最大容量 Manager-Last = -1; // 初始为空表 return Manager; // 返回管理体指针/* 判断顺序表是否已满 */bool SeqList_IsFull(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last + 1 == Manager-MaxSize); // 满返回true，否则false/* 判断顺序表是否为空 */bool SeqList_IsEmpty(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last == -1); // Last为-1表示空表/* 头插：把data插入到表头（下标0位置） */bool SeqList_HeadAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; // 把原有元素整体后移一位 for (int i = Manager-Last; i = 0; --i) Manager-Addr[i + 1] = Manager-Addr[i]; Manager-Addr[0] = data; // 新元素放入头部 Manager-Last++; // 更新Last return true;/* 尾插：把data追加到表尾 */bool SeqList_TailAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; Manager-Addr[++Manager-Last] = data; // 先Last+1，再写入数据 return true;/* 按值删除：删除第一个等于data的元素 */bool SeqList_Del(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表无法删除 printf(顺序表为空，无法删除 ); return false; int i = 0; // 找到第一个等于data的元素下标 while (Manager-Addr[i] != data i = Manager-Last) i++; if (i = Manager-Last) // 找到了 // 把后面元素整体前移一位覆盖掉被删元素 while (i Manager-Last) Manager-Addr[i] = Manager-Addr[i + 1]; i++; Manager-Last--; // 元素个数减1 return true; // 没找到 printf(此顺序表中没有找到你指定要删除的数 ); return false;/* 打印整个顺序表 */bool SeqList_Print(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表提示 printf(元素为空无法打印 ); return false; // 逐个元素打印 for (int i = 0; i = Manager-Last; ++i) printf(Addr[%d]=%d , i, Manager-Addr[i]); return true;/* 销毁顺序表：先释放数据区，再释放管理体 */void SeqList_Destroy(SeqList_t *Manager) if (!Manager) return; // 空指针直接返回 free(Manager-Addr); // 释放数据区 free(Manager); // 释放管理体/* 主函数：简单测试 */int main(int argc, char const *argv[]) // 创建一个容量为5的顺序表 SeqList_t *list = SeqList_Create(5); // 尾插5个元素 SeqList_TailAdd(list, 10); SeqList_TailAdd(list, 20); SeqList_TailAdd(list, 30); SeqList_TailAdd(list, 40); SeqList_TailAdd(list, 50); SeqList_Print(list); // 打印当前表 printf( ); // 删除3个元素 SeqList_Del(list, 10); SeqList_Del(list, 30); SeqList_Del(list, 50); SeqList_Print(list); // 再次打印 SeqList_Destroy(list); // 用完销毁 return 0; 当然作为一个初学者我所写的代码还存在着可以优化的地方，但从逻辑上来分析我所写代码的优势就在于逻辑清晰。放在学生作业、嵌入式底层库中、面试笔试场景中都有不少亮点。 代码优势1.结构设计： 我将管理元数据与数据区彻底分离。2.接口语义清晰： 我大部分函数都使用的bool返回，失败false、成功true，语义单一。3.可裁剪性高： 没有任何全局变量静态变量。4.精确的错误信息： 每条错误都带由中文提示。5.空指针的保护密度： 每个接口都做了 if (!Manager) return false;。6.初始化策略： 选择使用calloc，使用malloc需要手动添加memset。7.数据类型： 可以更改数据类型，提高了泛型能力。 代码缺点 内存申请失败直接 exit，把库变成了进程杀手，嵌入式或插件场景根本没法优雅降级。 容量固定，没有扩容接口，浪费内存。 头插和删除用循环搬数据，O(n) 最坏复杂度。 按值删除只清掉第一个匹配项，想全删得外层再套循环，时间平方级。 只有头插尾插，没有按位置插入，用户想往中间放元素只能自己拼“删了再插”的野路子，还是 O(n²)。 没有 FindIndexOf 这类只读定位，判断存在性只能裸翻内存或打印人肉搜索，封装性被击穿。"},{"title":"2025年9月-10月总结","path":"/2025/10/18/2025年9月-10月总结/","content":"这是我2025年至2026年的规划，截至至2025年10月18日我已经学完了c语言，预计至10月25日学完嵌入式该具备的数据结构知识。为应对软件考试：嵌入式系统设计师，我也在阅读《嵌入式系统设计师教程》，预计明年报考。 c语言部分笔记展示 阅读《嵌入式系统设计师教程》部分笔记 深入学习了计算机的基础知识，计算机的包括组成结构，运行逻辑以及原理。对计算机的重要部件进行了研究。 数据结构部分笔记展示 数据结构与c语言紧密结合，既有对c语言代码运行的底层逻辑，对程序运行中涉及到的各个器件、内存都必须要有深刻的了解。 总结 这是我的第一篇博客，今后我会将我的各个阶段的总结、成果、笔记上传至此博客，既是对我个人的积累，也是希望我所分享的内容能为他人带来帮助。"}]