[{"title":"GPIO外设细节分析","path":"/2025/12/01/GPIO外设细节分析/","content":"基于stm32f103c8t6以及参考stm32f40x 点亮LED灯基于STM32f103c8t6的电灯程序 使用STN32f103C8T6在GOIP_InitTypeDef结构体中缺少两种模式1.指定GPIO引脚的输出类型2.指定GPIO引脚的内部结构 点亮LED灯的基本代码 #include stm32f10x.h//1.定义GPIO外设的结构体变量GPIO_InitTypeDef GPIO_InitStructure;int main() //2.打开GPIOB端口的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //3.配置PB9为输出引脚 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //对GPIOB端口进行初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_Init(GPIOB, GPIO_InitStructure); while (1) GPIOB-BRR = GPIO_Pin_9; // 拉低 GPIOB-BSRR = GPIO_Pin_9; // 拉高 GPIO_InitTypeDefstm32f103c8t6对该结构体的定义 stm32f40x对该结构体的定义 GPIO外设原理（1）打开时钟要使用GPIO外设，必须提前打开GPIO端口外设时钟，需要使用ST提供的函数 打开外设时钟的原因：因为STM32属于低功耗的MCU，而为了降低功耗STM32的MCU在复位之后会默认关闭绝大数的外设时钟所以用户在使用MCU内部的某个外设，就需要打开该外设的时钟 控制硬件就需要控制硬件的寄存器数字电路角度，寄存器的作用是暂存一组二进制数据，32bit的寄存器能暂存32bit的数据原因是寄存器内部是由一组触发器级联组成，触发器可以暂存1bit数据而触发器在数字电路中属于时序逻辑 寄存器：用来存储一组二值代码一个触发器能储存1位二值代码，N个触发器组成的寄存器能储存一组N位二值代码对于寄存器中的触发器只要要求它们具有置1、置0的功能即可 触发器：能够存储1位二值信号的基本电路统称为触发器 触发器必须有两个特点：1.具有两个能自行保持的稳定状态，用来表示逻辑状态的0和12.在触发信号的操作中，根据不同的输入信号可以置成1或0的状态 触发方式一般为电平触发、脉冲触发、边沿触发 边沿触发：上升沿和下降沿被称为边沿 电平触发 移位寄存器 触发器是需要触发的，不管是边沿还是电平触发，必须外部提供持续的脉冲信号 OSC晶振引脚STM32F103 的 OSC 引脚（PD0OSC_IN 和 PD1OSC_OUT）即使没有外接晶振芯片内部的时钟树仍然可以为寄存器中的触发器提供脉冲信号 时钟相当于外设的开关，不打开时钟，则晶振产生的振荡信号就无法输入到MCU内部的外设中则没有时钟信号，触发器无法触发，则触发器无法锁存数据而寄存器是由N个触发器组成，所以寄存器就无法工作而控制硬件必须通过寄存器实现 //2.打开GPIOB端口的时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); STM32f103C8T6SYSCLK（内核主频）最大 72 MHzAHB 总线（HCLK）直接等于 SYSCLK，所以也是 72 MHzAPB1 总线（PCLK1）最高 36 MHz（如果 SYSCLK72 MHz，则缺省 2 分频）APB2 总线（PCLK2）最高 72 MHz（可以 1 分频） STM32f40x STM32的MCU内部有多个外设，作用性能都各不相同，使用的时钟频率也不同ST公司为了降低芯片功耗，把不同性能的外设挂载在不同性能总线上需掌握3条总线AHB高级高性能总线（总线频率是168MHZ）、APB1高级外设总线（42MHz）、APB2高级外设总线（84MHz） 而MCU内部的外设的性能不同，需要把外设挂载到对应的总线，利用总线对外设进行控制 总线和外设的关系总线和外设的关系相当于高速公路和汽车的关系，高速公路分为快慢车道而汽车性能较低则需要到慢车道，性能较高则需要到快车道行驶 参考手册中可以查询到需要使用外设总线 指定AHB1总线下的外设时钟，可以是任意组合 打开端口对应的地址 打开了GPIO外设的时钟之后，可以对GPIO外设的初始化结构体中的成员进行赋值 （2）设置GPIO引脚的编号 （3）设计GIPO引脚的模式IN 输入模式（较常用） OUT 输出模式（经常用）AF 复用模式（偶尔用） AN 模拟模式（总也不用） GPIO功能描述 推挽和开漏模式的区别推挽模式能输出高电平和低电平开漏模式只能输出低电平 使用两个三极管可以降低功耗 （4）设计GPIO的内部电阻 （5）设置GGPIO的速度输出速度指的是引脚电平的翻转速度，如果选择高速，则会增加功耗和噪声如果不知道选择哪种，则选高速即可 如果设置好了各个GPIO结构体的各个成员的值需要把架构体中的值写入到GPIO端口寄存器 三极管NMOS管可以理解为PNP型三极管PMOS管可以理解为NPN型三极管 导通条件：NPN型三极管在基极加高电平PNP型三极管在基极加低电平"},{"title":"USB、串口等基本原理与结构","path":"/2025/11/28/USB、串口等基本原理与结构/","content":"USBUSB：通用串行总线特点：快速简单连接、成本低、扩展PC连接外设范围、可由外设提供电源USB2.0传输速率可达 480Mbs USB系统只有一个端口和一个中断 USB支持热插拔和PNP，随插随用，需动态加载驱动程序 供电方案：1.pc通过USB电缆供电2.通过电池或其他设备供电 传输类型1.控制传输2.数据传输3.中断数据传输4.同步数据传输 USB具有较灵活的扩展性，一个USB端口可通过USB Hub扩展为多个USB端口 串口串口通信：设备之间通过一根导线传送信息优点：传输线少、成本低、适合远距离传输缺点：传输速度慢，传送n位数据需要时间T，传送时间最少为nT （1）RS-232C 串口RS是英文“推荐标准”的缩写 232为标识号，C表示修改次数RS-232C总线标准设有25条信号线，一个主通道，一个辅助通道一般的双工通信只需一条发送线、一条接受线、一条地线即可实现 抗干扰能力弱 RS-232C标准规定的传输速率为每秒50、75、150、300、600、1200、2400、4800、19200bite 嵌入式板卡上一般配置有串口，遵循RS-232总线标准 （2）RS-485串口 在通信距离达到几十米到上千米时，广泛采用RS-485串行总线标准该标准采用平衡发送和差分接收，具有抑制共模干扰能力 总线接收灵敏度高至检测低至200mV的电压，因此信号能在千米外得到恢复 RS-485采用半双工工作方式 红外红外接口 英文简称为IrDA 红外接口是一种基于无线传输协议以及基于该协议的无线传输接口 红外接口可以在同样具有相同接口的设备之间进行信息交流 优点：安全性较强缺点：通信距离短、通信过程中不能移动、功能单一，扩展性差 并口并行接口简称并口，LPT接口采用并行通信协议的扩展接口并行接口的传输速率比串行接口的速率快八倍，为1Mbs一般连接打印机、扫描仪 （1）IEEE 488IEEE 488总线是并行接口标准，该总线用来连接系统该总线按照并行、字节串行双向异步方式传输信号仪器设备直接并联总线上而不需要中介单元 总线最多连接15台设备、最大传输距离为20米、信号传输速度为500Kbs~1Mbs （2）SCSI用于计算机与硬盘驱动器之间传输数据 （MXI）多系统扩展接口总线32位并行互连总线，最高速度可达23Mbs，传输距离20mMXI采用硬件映像通信设计MXI器件通过读写相应的地址空间就可直接访问其他所有器件资源 SPISPI:串行外设接口，是一种同步串行外设接口它可使MCU与各种外围设备以串行方式进行通信以交换信息 SPI有三个寄存器：控制寄存器SPCR、状态寄存器SPSR、数据寄存器SPDR 外围设备包括：FLASHRAM、网络控制器、LCD显示驱动器、AD转换器、MCU等 该接口使用4条线1.MOSI:主器件数据输出，从器件数据输入2.MISO:主器件数据输入，从器件数据输出3.SCLK：时钟信号，由主器件产生，最大为fpCLK2，从模式频率最大为fcPU24.NSS：从器件使能信号，由主器件控制，有的IC会标注为CS I^2C该总线接口用于连接微控制器及外围设备 接口特点：1.该总线有2根信号线：一根双向的数据线SDA、一根时钟线SCL2.该总线的外围器件都需要唯一的地址，器件地址是器件固有的地址编码，不可更改引脚地址是该总线的外围器件的地址引脚决定3.主从双向通信，该总线由主机控制，别主机所寻访的设备都为从机 总线竞争：由两个或两个以上的器件占用总线该总线可以对发生在SDA线上的总线竞争进行总线仲裁 IEEE 1394俗称火线接口IEEE 1394分为两种传输方式：1.Backplane模式，传输速率为12.5、25、50Mbs2.Cable模式，100、200、400、Mbs，最多支持63个设备 IEEE 1396接口协议分为三层：事务层、物理层、链路数据层事务层只支持异步传输，同步传输由链路层提供 接口类型： CAN控制器局域网最初被用于汽车环境中各种设备的微控制器通信 CAN总线具有很高的实时性能 高抗电磁干扰、可以检测出任何错误"},{"title":"2025年11月个人总结","path":"/2025/11/27/2025年11月总结/","content":"在这一个月以来在我的学习历程中还是面临着各种挑战，包括学习效率低下，学习计划方向不明确用了大把大把时间实际却只掌握了小部分知识一到周末就完全不想去学习了，暴露了我很多缺点。 博客11月在CSDN发布博客共7章原创博客 其中高质量文章共5章 这是我CSDN上写博客的第一个月，截至目前为止共有5156的收藏量132的收藏量 在个人博客下发布8篇文章 都是关于嵌入式学习过程中的重要的知识笔记 在我下个月的计划中编写博客的文章必须超过本月所写文章数量并且在dev.to写一篇英文博客并发布 时间在11月的时间利用中严重不足，一部分因为学校课程的关系包括个人精力难以让我维持较高的专注力去学习新知识 在现在还存在的问题主要是在周末时间上的利用一道周末我就“摆烂”，不学习只玩。我决定在下一个月中周六可以玩一天至少周日必须学习 在工作日中我在每天的晚上给自己设置的是自由时间有时候是在学习搞项目有时候在玩游戏刷视频看小说至少在下一个月中夜晚学习的时间的天数要与玩的天数持平 效率在这一个月我阅读了嵌入式系统设计教程第二版可阅读的效率也是非常的低，刚刚读完第二章掌握的程度也不是一想就会 最近我也一直在思考如何提高自己的学习效率我也相信只有更好的提升自我能力才能在更多复杂的知识前不至于逃避我现在也只能用大把大把的学习时间，慢慢体会这个提升效率的过程 包括我背四级单词的效率也是非常的慢到目前为止我也没有一个实际的方法去解决 这个月我能把Linux基础入门发知识学完对我以后学习嵌入式开发会有很大的帮助 目标1.下个月完全投入学习中，开始嵌入式项目实战2.c++编写一个较有含金量的项目3.认真阅读嵌入式系统设计师教程4.学过的内容要时常回头复习 挑战人一旦摸到点上限就会渴求更高的上限我也一样若我能完成我的目标我也会在未来给自己设计更大的挑战最好希望看到这篇博客的人也能有一个更好的未来"},{"title":"嵌入式系统总线及通信接口","path":"/2025/11/24/嵌入式系统总线及通信接口/","content":"PCI、PCI-E等接口基本原理与结构PCI外设部件互连标准它定义32位数据总线，并且可扩展为64位 特点： （1）高速性33或66MHz，32 位下峰值 132 MBs，64 位下 264 MBs的传输速率 （2）即插即用PCI板卡的硬件资源根据微机各自要求统一分配，不必关心是否产生冲突 （3）可靠性结构：独立于处理器结构，中间缓冲器的设计方式在不同时钟频率下不必担心导致性能下降PCI总线增加了奇偶校验错、系统错 （4）复杂性硬件上采用大容量、高速度的复杂可编程逻辑器件CPLD或FPGA芯片软件上则需要根据所用的操作系统编制支持功能的设备驱动程序 （5）自动配置PCI插卡插入系统BIOS自动为插卡分配存储地址、中断、和某些定时信息 （6）共享中断采用低电平有效方式，多个中断可共享一条中断线 （7）扩展性高采用多级PCI总线，这些总线上均可并发工作与ISA、EISA、MCA总线完全兼并 （8）多路复用地址总线和数据总线共用一组物理线路通过“时分复用”完成先地址、后数据的传输 （9）严格规范PCI总线对协议、时序、电气性能、机械性能都有严格规定接口的实现有较高的难度 PCI-E基本架构；根组件、交换器、各种终端设备PCI-E 在带宽、传输速度、扩展性和兼容性等方面都优于传统的 PCI EISA在ISA的基础上使用双层插座，在其98条信号线基础上又增加98根信号线EISA完全兼备ISA总线 VME数据传输机制：异步地址宽度：16、24、32、40、60数据线路宽度：8、16、24、32、64数据传输速率为0~500MbsUnalign Data传输能力、误差纠正能力、自我诊断能力 CPCI高性能工业用总线 PCMCIA专门用在笔记本或PDA、数码相机等便携性设备上的一种接口规范 PCMCIA总线分为两类：一类为16位的PCMCIA，一类为32位的cardBus"},{"title":"GPIO外设","path":"/2025/11/18/GPIO外设/","content":"GPIO的概念GPIO（Gener Purpose InputOutput）是外设中最基本的且最通用的外设GPIO引脚核心作用是作为通用的输入输出口 FLASH的起始地址：0x0800_0000 MCU识别电信号 通过RST引脚传输0，跳到起始电路（参考复位电路） BOOT0和BOOT1引脚；设置自举模式 GPIO的定义对某个引脚进行高低电平的输出，以及检查某个引脚的电平状态TTL电平协议：+5V等价于逻辑‘1’，0V等价于逻辑‘0’电平范围：大于2.4V表示高电平，小于0.4V表示低电平 电源引脚：VCC、VDD、VSS、VDDA、VSSA、VREF+等电源引脚晶振引脚：PC14、PC15、PD0、PD1（带有OSC）属于晶振引脚也可作为其他功能使用复位引脚：NRST属于复位引脚BOOT引脚：BOOT是专用引脚，BOOT1属于功能引脚（设置芯片的自举模式）GPIO引脚：该芯片共有48个引脚，GPIO引脚有37个下载引脚：PA13、PA14、PB3、PB4等都属于下载引脚（JTAG、SWD） 引脚的命名一般IO口的命名由P（Pin）开头，分为很多端口，以字母A至H来命名每个组（端口）有16个引脚，引脚编号为0至15，即端口A的引脚范围为：PA0至PA15，端口B的引脚范围为：PB0至PB15 例如：51单片机也有IO口，一般8051有40个引脚，其中1个复位引脚，2个晶振引脚、2个电源引脚，3个存储选择引脚，剩下32个引脚作为IO口8051把31个IO口进行分租，分为4个端口，每个端口8个引脚，端口是以数字03进行分区，每个端口的8个引脚是以数字07进行区分P00P07、P10P17…… 引脚的功能一般的默认功能都是输入输出引脚也有其他的功能被称为第二功能，只能使用ADC通道和DAC需要把引脚设置模拟模式其他情况下想要把引脚当作别的功能使用，需要把引脚设置复用功能需了解更多功能需要查阅数据手册 以STM32F40x芯片手册为例： GPIO外设的使用学习硬件开发，一般都从点亮LED开始，主要是以基础外设作为入门，掌握外设的控制流程 LED灯原理 发光二极管：具有单向导电性，因为极管内部有一个PN结（P型半导体和N型半导体组成） 导体半导体绝缘体 半导体材料：硅、锗 硅是晶体结构，内部不含杂质，所以这种半导体也被称为本征半导体 电阻：保护二极管 如果二极管的电流的阈值是10mA 输出高电平，LED灭，两端电压一样无法产生电势差 输出低电平，LED亮，形成电流回路LED灯亮 为人为控制导电能力需要向本征半导体加入元素 P型半导体：positive 向硅晶体加入少量的硼元素，硼元素：5 最外层有3个价电子 N型半导体：negative 向硅晶体加入少量的磷元素，磷元素：15最外层有5个价电子受温度影响，会做热运动，磷元素最外层剩余的1个价电子会受到热运动的影响，脱落束缚，会变成自由电子，带负电"},{"title":"定时器和计数器","path":"/2025/11/17/定时器和计数器/","content":"从硬件角度看，定时器和计数器是一样的，其差别在于在特定应用中的使用情况 硬件定时器系统时间：由定时器计数器产生的输出脉冲触发中断而产生输出脉冲的周期叫一个滴答，表示发生一次时间中断 实时操作系统提供的定时器硬件功能包括： （1）初始化定时器：负责定时器的相关寄存器，滴答的时间间隔，以及挂载系统时钟中断处理程序 （2）维持相对时间和日历时间：相对时间间隔就是相对于系统启动以来的时间，发生一次滴答，系统相对时间增加1内核可以实时获取启动时刻的日历时间 （3）任务有限等待的计时：用时间等待链来组织需要延迟处理的对象或任务 （4）时间片轮换调度的计时：在时钟中断服务程序中对正在运行的以执行时间数值加1加1后若任务已执行时间同任务的时间片相等，则结束运行转入就绪队列 软件定时器实现定时功能，内核需要支持软件定时器管理功能，用户就可以根据需求创建、使用软件定时器软件定时器的定值计数为0时，触发定时器的时间服务例程，用户在此例程中完成自己需要的操作在中断服务处理程序中需要对软件定时值进行减1操作 软件可实现看门狗功能在应用某个地方执行软件定时器的停止计时操作，确保定时器在系统正常运行的情况不会到期，不会触发定时器服务例程如果某个时候系统进入了定时器服务例程，则停止定时操作没有被执行到，系统出现错误 可编程间隔定时器可编程间隔定时器（PIT）又称计数器主要功能：时间计数和生成时间中断，以解决系统时间控制问题 PIT的典型原理如图： 通信寄存器在计数硬件和操作系统之间建立联系操作系统通过这些寄存器控制计数硬件的工作方式，读取硬件当前状态和计数值等信息操作系统内核初始化时，内核向定时、计数器写入控制字和计数初值而后计数硬件就会对晶振产生的输入脉冲进行计数操作计数器从计数初值开始每收到一次脉冲信号，计数器就减1。当减到0时，就会输出高低电平开始从计数初值开始重复另一次计数，从而产生一个输出脉冲"},{"title":"自举模式的选择","path":"/2025/11/13/自举模式选择/","content":"学习使用STM32会写代码反而不是重点，重点是会看懂各种手册，包括参考手册、数据手册等等，国内的中文手册大多都是机翻，翻译会出现一些不准确的用词，继而学会英语能提高在这个行业上的高度，但今天重点不是这个，而是如何去了解STM32相关芯片 本文以STM32F10x为例 自举配置此图片的启动配置实际上是自举配置译者应该是把Bootstrap翻译成了启动 引脚：引出来的管脚BOOT[1:0]引脚决定选择三种不同的自举模式BOOT[1:0]有两个引脚：BOOT0引脚、BOOT1引脚 此图是STM32F10x数据手册中48引脚芯片 BOOT0是44号引脚 BOOT1是20号引脚，BOOT1 引脚（PB2）在启动时具有特殊功能，启动完成后可恢复为普通 GPIO 使用找BOOT0和BOOT1不应该在开发板去找，而是看原理图，一般数据手册和参考手册上没有原理图 上图为BOOT的原理图，在开发板上一般包括两个跳线帽跳线帽可作用于引脚短接，一个条线帽容纳两个排针 GND 地 （负极0V）、 VCC 电源（正极3.3V） 、VDD也是电源 STM32F103C8T6的6个排针是 0 boot0 10 boot1 10接地，1接电源（接VCC，通电状态，用逻辑1表示） 上图的自举配置中 BOOT1下的x表示可以接1也可以接0 自举中的三种模式1.主Flash模式，选择Flash作为自举空间闪存容量是64KB，闪存存储器属于ROM的一种掉电不丢失数据闪存有使用寿命，原理：黑板原理，先擦除再写入，可以反复擦除十万次左右如果把程序下载到Flash中并且打算从Flash中启动程序，则需要让CPU跳转到0x08000000这个地址下开始执行 大小为：块扇区编程页字节如图以STM32F103C8T6为例Flash容量为64KB则共有64页，且每次擦拭是按页擦拭的 2.系统存储器如图大小为2KB，一般无法向其中存数据，是芯片厂商使用的，是厂商提供的启动引导程序BootLoader必须借助厂商提供的工具下载程序，一般都是采用串口实现程序下载，但偶尔会导致芯片锁死 3.嵌入式SRAM（静态随机访问存储器） STM32F103C8T6芯片内部的SRAM的大小是64KB，特点掉电丢失调试时可以下载到SRAM中使用 一般使用主Flash就够用了即BOOT0接0，BOOT1也接0 复位电路接好后需要复位，一般标记的RESET为复位按键 复位电路的原理图复位电路必背，芯片的复位引脚需要低点平复位，电容作用：充电放电特性。电阻作用：给电容充电原理：VDD3V3给电容充电一直保持复位引脚为高电平，触摸按钮后电流不再经过电容，电容放电（过程很短）复位引脚接收低电平 两种情况：1.开始按复位，下载程序，开始执行程序2.下载程序，按复位，开始执行程序 一般采用TTL电平协议来表示一个管脚的状态"},{"title":"通用输入输出接口和模块数模接口","path":"/2025/11/12/嵌入式系统设备接口/","content":"嵌入式系统是面向应用，不同的应用所用的接口和外设不同。接口是CPU和IO设备之间交换信息的媒介和桥梁，CPU和外部设备、存储器的连线和数据交换都需要通过设备接口来实现 通用输入输出接口同用输入输出接口是是一组输入引脚或输出引脚，CPU能够对它们进行存取，并且有些引脚可以可以通过编写改变工作方向 双向GPIO端口的简化功能逻辑图 DDR数据方向寄存器：设计端口的方向。该寄存器输出为1，则端口为输出，输出为0，则端口为输入若想要改变DDR，则需将恰当的值置于D0，同时激活WR_DDR信号读取DDR单元的状态，同时激活RD_DDR信号 若PORT引脚置为输出，由PORT寄存器控制该引脚状态，若将PORT引脚设置为输入，则此输入引脚状态由引脚上的逻辑电路层来实现对它的控制对PORT寄存器的的写入，将激活WR_PORT信号 DDR和PORT寄存器都映射到微控制器的地址空间 模块数模接口、1.数模转换接口（AD转换器）AD转换器就是把电模拟量转化成数子量的电路 实时监测系统和实时控制系统都离不开模数转换器1.在实时控制系统中传感器把实时现场的各种信号（温度、流量、压力、PH值、位移）测量出转换成对应的电信号2.通过各种方式处理电信号后送到AD转换器，由其将电信号转换成数字模拟量信号3.微机采集后按照一定算法输出控制量，再输出数据经过DA转换器去控制执行机构 实现AD转换的方法有：计数法、双积分法和逐次逼近法 在这里嵌入式系统设计师教程和实际工业模型不一样1）计数法1.每次转换开始前，积分器把电容放电为0，计数器复位2.计数器准备计数，计数器输出数字为0，0送至DA转换器输出0V模拟信号3.比较器输入带转换的模拟输入电压Vi大于V0（0V）使计数控制信号C为14.计数器开始计数，从DA端得到的数字量不断增加，致使输出电压Vo也不断上升5.VoVi时，比较器输出低电平，使计数器控制信号为0，计数器停止计数6.计数控制信号有高到低的负跳通知计算机完成一次AD转换 2）双积分法1.基本原理是对模拟电压和参考电压进行两次积分2.得出输入电压均值成正比的时间间隔，利用时间间隔和计数器测出其时间间隔3.此类的DA转换器具有较强的抗干扰能力，转换精度高，速度较慢，适用于数字式测试仪表、温度测量等4.步骤：对待测的模拟电压进行固定时间的积分，然后换至标准电压进行固定斜率的反向积分，反向积分至一定时间，返回起始值。对标准电压进行反向时间T正比于输出模拟电压，输入模拟电压越大，反向积分回到起始值时间越长。即只要用标准的高频时钟脉冲测定反向积分花费时间，可得到相应于输入模拟电压的数字量，实现AD转化 3）逐次逼近法逐次逼近式AD转换于计数法转换大致一样。它通过DA转换器从高位到低位逐次增加转换位数，产生不同的输出电压，将输入电压与输出电压进行比较而实现不同之处在逐次逼近式使用了一个逐次逼近寄存器存放转换出来的数字量，转换结束时将数字量送至缓冲寄存器 数模转换接口通常采用T型网络实现将数字量转换成模拟电流，然后再用运算器放大器完成模拟电流到模拟电压的转换。目前大部分AD转换器都集成了这两个环节但对只包含第一个环节的AD转换器就需要额外配置运算器和放大器完成转换"},{"title":"高速缓存与其他存储设备","path":"/2025/11/11/高速缓存与其他存储设备/","content":"本文为嵌入式系统设计师教程相关阅读笔记，记录学习内容以便后来查看以及分享我的学习积累 高速缓存Cache位置：位于处理器和外部内存之间速度比RAM更快的存储器一般称之为高速缓存器 当处理器执行程序时需要不断的访问内存，而读取内存的速度比CPU慢，严重制约系统实际性能 CPU总是访问当前内存地址的相邻地址，符合局部性访问原理，基于此原理通过在CPU和外部存储器之间设计高速缓冲器，可使CPU进行外部存储设备的局部存储，可提高对CPU对外部存储设备的访问效率。 Cache的主要作用：对外部存储设备的缓冲Cache的组成：内部由块号和块内偏移组成原理：(1)Cache收到CPU访问内存地址 (2)Cache将CPU访问内存的地址分解为块号和块内偏移 (3)利用分解的块号查找Cache内部的Cache块 (4)通过（3）找到一个即为命中，再用块内偏移区索引该块中的数据：当前是读内存即可立即将Cache中缓存的数据返回给CPU；如果是写操作：1）Write-Through（写直达）动作：数据同时写入Cache和主存优点：数据一致性高，主存始终是最新的缺点：写操作慢，因为每次都要写入主存2）Write-Back（写回）动作：数据写回Cache，不立即写入主存，当Cache行替换时才写回主存优点：写操作快，减少主存访问次数缺点：数据一次性差，主存数据不是最新的3）Write-Allocate（写分配）动作：写操作时，若数据不在Cache中，先将数据加载到Cache中再写入通常与Write-Back搭配使用优点：后续写操作可以命中Cache缺点：首次写操作需要额外一次读操作4）NO-Write-Allocate（非写分配）动作：数据不在Cache中直接写入主存，不加载到Cache通常与Write-Through搭配使用 例子：采用Write-Back（写回）和Write-Allocate（写分配）写入一个地址，如果Cache命中，只写Cache，标记为dirty写入一个地址，如果Cache不命中，先从主存加载该地址的数据到Cache，然后再写入Cache，并标记为dirty当该Cache行被替换时，才会把dirty数据写回主存 (5)如果未命中，Cache首先查找内部Cache内部有没有空闲块，若找到了空闲块，就在该块中装入CPU访问内存地址对应的内存块，若是读内存操作就把这个地址对应的数据返回给CPU，写入操作根据类型不同，动作也不同 (6)如果没有找到空闲块，则需要使用Cache管理中的块替换策略，找到Cache中可替换出去的块，如果是读内存操作，那么根据替换块的块号和状态，Cache会决定是否把这个块写刀内存中，同时把这个地址对应的数据返回给CPU，写入操作根据类型不同，动作也不同 Cache出现命中和不命中的原因： Cache 只是主存的一小部分“副本”，不可能把全部内存都装进去，所以任何映射策略都必然出现 现代计算机默认路径是Cache，CPU读取内存任何数据都会经过Cache但机器里还有大量刻意绕过 Cache 的区间：1.内存映射 IO（MMIO）、PCIe BAR、显卡帧缓冲2.DMA 共享环形缓冲区、网卡描述符队列3.由驱动标记为 UCWC 或 ARM DeviceGreedy 的页这些区域 CPU 一访问就直接走内存总线，不进任何 Cache 层次 Cache的重要作用Cache通过提高CPU访问效率来缓解CPU和内存之间的速度不匹配 Cache的工作机制示意图 其他存储设备1.快闪存储器（FLASH）简称闪存，闪存的大部分芯片需要块擦拭，正因为写入速度较快，所以称为闪存 FLASH分为两类；NOR FLASH和NAND FLASH（1）NOR FLASH任何FLASH的写入操作只能在空或已擦拭的单元内进行，即在写入操作前必须进行擦拭，NOR FLASH在擦拭前把先将目标块内所有位都写为0NOR FLASH带有SRAM接口，易存取其内部每一个字节，可直接连接系统总线构成内存储器 （2）NAND FLASHNAND器件使用复杂的IO口来串行的存取数据，但不能构成内存，只能构成外存储器NAND的读和写操作一般采取512字节的块 两者对比1.NOR的读速度比NAND快，但NAND的写入速度远比NOR快2.NAND的擦拭速度远比NOR的快，因为NAND的擦拭单元更小，擦拭电路更少3.NOR FLASH上可直接运存程序，NAND FLASH只能存储信息 2.磁盘、光盘等存储介质 1）磁盘磁盘存取速度都最快、具有较大的存储容量 磁盘存储器是由盘片、驱动的器、控制器和接口组成1.盘片的两面用来存储信息2.驱动器控制数据的写入和读写3.控制器接收主机发出的命令，控制磁盘驱动器写入和读写，实现主机与其的数据转移和传送4.接口是主机和磁盘存储器之间的连接逻辑 磁盘也被称为硬盘存储器，其作用原理和组成大致相同硬盘驱动器内使用了多个盘片，提高了存储器的存储容量 硬盘的接口方式决定了硬盘的性能常见的接口有IDE（ATA）和SCSI，还有一些采用PCMCIA或USB接口IDE用于普通用户SCSI用于服务器等高端应用场合 2）光盘利用磁头变化和磁头电流进行读或写 3）CF（Compact FLASH）IDE接口的固态硬盘，块存耐震大容量，针脚多、体积大 4）SD（Secure Digital Memory Card）基于半导体快闪记忆器，重量轻、高记忆容量、快速数据传输、极大的移动灵活性和很好的安全性"},{"title":"STM32开发板概述","path":"/2025/11/06/嵌入式概述/","content":"国内定义：嵌入式就是以应用为中心，以计算机技术为基础，软硬件可裁剪，适用于对于体积、可靠性、功耗、性能等方面严格要求的专用计算机系统。 微控制器的关系现在的市场需求：成本低、性能高、功耗低、多任务、易用界面 基于市场需求ARM公司 ARM公司的开发 学习STM32的原因STM32系列介于低端和高端芯片之间，相较于低端芯片STM32拥有强大的内核架构、更多的片上外设、可以运行uCOS、freeRTOS等实时操作系统，相较于高端芯片STM32成本更低、实时性较强。所以学习STM32是大多数嵌入式开发人员的必经之路。 学习STM32不仅仅对相关外设（串口、定时器等）进行学习，而是要掌握软件的设计流程，这样在设计一款产品的时候才知道如何进行器材选择、协议选择、数据格式等，并且大多数的产品都会搭载实时操作系统，所以也要掌握实时操作系统设计架构和使用方法。 STM32的应用领域STM32属于微控制器MCU，自带各种通信接口 1.工业 电机控制（FOC、伺服）、PLC、工业网关、机器人、数控、智能传感器、电源管理（数字电源、UPS）。 汽车 车身控制（BCM、车窗、座椅、车灯）、BMS、车载充电器、数字仪表、T-Box、ADAS 边缘节点、E-bikeEV 小电机。 消费 手机PC 外设（触控板、摄像头模组、快充协议芯片）、可穿戴（手环、手表）、平衡车、电子烟、玩具、小家电（空调、冰箱、洗衣机、咖啡机）。 物联网与边缘计算 智能表计（水、电、气、热）、资产追踪、智能门锁、烟感、Beacon、Sub-GLoRa、Wi-Fi、BLE、Cat-1NB-IoT 模组的主控或协议栈 SoC。 医疗与保健 便携血氧仪、血压计、胰岛素泵、一次性内窥镜、健身设备、心电贴片。 图像与音视频 扫码枪、条码二维码识别、微型打印机、电子词典、教育点读笔、USB-C 耳机、麦克风阵列。 航空航天与国防 小型无人机飞控、卫星姿控、火箭地面测试设备、导弹舵机、单兵设备（低功耗、抗辐射型号）。 教育 高校嵌入式教学、开源硬件（Arduino 兼容板）、竞赛、创客项目、RT-ThreadFreeRTOS 实验平台。 就业前景STM32 并非终局，而是嵌入式职业路径中的关键过渡技术节点。 其生态完备、迭代连续，在可预见的 10 年周期内仍将为不同计算平台提供硬件抽象与实时控制基准。 2025 年产业缺口集中于“以 STM32 为起点，具备向 Linux、边缘 AI 或车规级架构跃迁能力”的复合型人才；跃迁幅度直接决定薪酬分位，市场对能完成技术栈纵向扩展者的定价显著高于单一 MCU 开发者。 STM32开发方式主流的三种开发方式：函数库开发、寄存器开发、图形界面开发 （1）STM32 寄存器开发 STM32的资源外设比较丰富，所以导致寄存器的数量增多并且复杂度增大，要求开发人员掌握底层开发的相关知识。 一般情况涉及实时性要求较高，频繁调用的中断服务函数才会直接使用寄存器开发。 （2）库函数开发 ST公司开发了两套库标准外设库、HAL库。目前标准外设库已经停止维护，但是目前绝大数公司依旧采用标准外设库进行项目开发。 STM标准外设库是ST公司专门针对STM32提供一系列API（函数接口），用户可以调用这些函数来配置STM32底层的寄存器，有利于快速开发和维护。 库是架设在寄存器和用户代码之间的代码，向下与寄存器相关，向上提供用户相关接口。 （3） 图形开发 ST公司设计都图形界面软件（STM32CubeMX）自动生成代码，用户只需要根据实际需求选择相应参数，即可 自动生成初始代码，极大提高开发效率"},{"title":"树","path":"/2025/11/03/数据结构“树”的知识点/","content":"树的概念节点（Node）-树中的每个元素。根节点（Root）-树的起点。叶子节点（Leaf）-没有子节点的节点深度：从根到该节点的路径长度。度-一个节点的子节点个数 树的分类满二叉树所有非叶子节点都有两个子节点，且所有叶子在同一层。完全二叉树除最后一层外，其他层都是满的，且最后一层从左到右填充。二叉搜索树左子树所有节点 根 右子树所有节点（中序遍历有序）。平衡二叉树BST 的左右子树高度差不超过1，保证 O(log n) 操作。红黑树自平衡 BST，通过颜色标记和旋转保持平衡（Java TreeMap、C++ STL 使用）。哈夫曼树带权路径长度最短的二叉树，用于数据压缩。线索二叉树利用空指针存储前驱后继，加速遍历。 树的遍历方式前序遍历（根 → 左 → 右） 中序遍历（左 → 根 → 右） 后序遍历（左 → 右 → 根） 树的应用文件系统 -目录结构是 N 叉树。数据库索引 -B 树、B+ 树用于磁盘索引（如 MySQL）。编译器 -语法树（AST）表示程序结构。压缩算法 -哈夫曼编码用哈夫曼树。路由协议 -默克尔树（Merkle Tree）用于区块链数据验证。优先队列 -堆（完全二叉树）实现优先级队列。 关于树的相关试题11.步骤一：寻找根节点步骤二：根据前序遍历和中序遍历的特点即可推出二叉树步骤三：后序遍历13.后序遍历e后直接是a（根节点）所以只有一个孩子节点a。假设二叉树采用二叉链式储存结构，设计一个算法，计算一棵给定二叉树的所有节点 int NodeCount(BiTree T) if (T == NULL) return 0; return 1 + NodeCount(T-lchild) + NodeCount(T-rchild); 递归思想写一个算法求一颗二叉树的深度，二叉树以二叉链表为储存方式 int Depth(BiTree T) if (T == NULL) return 0; int ld = Depth(T-lchild); int rd = Depth(T-rchild); return (ld rd ? ld : rd) + 1; 递归思想 相关代码/************************************** * file name : BST.c * author : 17866044205@163.com * date : 2025/11/2 * function : 用“双向不循环链表”实现 BST（二叉查找树）。 * 注：实际代码里仍然是经典二叉链，没有用到“双向”特性， * 也没有循环，名称容易误导。 * note : 该代码框架由本人所写，代码改进和注释由AI改进 * CopyRight (c) 2025 17866044205@163.com All Right Reserved ****************************************/#include stdio.h#include stdlib.h#include stdbool.h#include assert.htypedef int DataType_t;/* --------------- 节点定义 --------------- */typedef struct BSTNode DataType_t key; struct BSTNode *left; struct BSTNode *right; BSTNode;/* --------------- 内部工具：创建孤立节点 --------------- */static BSTNode *new_node(DataType_t key) BSTNode *n = (BSTNode *)calloc(1, sizeof(*n)); assert(n != NULL); /* 内存申请失败直接终止 */ n-key = key; return n;/* --------------- 对外接口：插入（可处理空树） --------------- */bool BST_insert(BSTNode **proot, DataType_t key) assert(proot != NULL); /* 调用者必须传合法指针 */ if (*proot == NULL) /* 空树场景：直接成为根 */ *proot = new_node(key); return true; BSTNode *cur = *proot; while (cur) if (key == cur-key) /* 重复键拒绝插入 */ return false; if (key cur-key) if (!cur-left) /* 找到空位，挂左子树 */ cur-left = new_node(key); return true; cur = cur-left; else if (!cur-right) /* 找到空位，挂右子树 */ cur-right = new_node(key); return true; cur = cur-right; return false; /* 不可达 *//* --------------- 中序遍历（打印） --------------- */void BST_inorder(const BSTNode *root) if (!root) return; BST_inorder(root-left); printf(%d , root-key); BST_inorder(root-right);/* --------------- 后序销毁（释放全部节点） --------------- */void BST_destroy(BSTNode *root) if (!root) return; BST_destroy(root-left); BST_destroy(root-right); free(root);/* --------------- 简单自测 --------------- */#ifdef BST_TESTint main(void) BSTNode *root = NULL; int arr[] = 50, 30, 70, 20, 40, 60, 80; for (size_t i = 0; i sizeof(arr)/sizeof(arr[0]); ++i) BST_insert(root, arr[i]); printf(InOrder : ); BST_inorder(root); /* 应该输出 20 30 40 50 60 70 80 */ putchar( ); BST_destroy(root); return 0;#endif"},{"title":"使用c语言实现顺序栈","path":"/2025/10/28/顺序栈的实现/","content":"我总结的实现顺序栈的步骤是 定结构 “顺序栈”需要使用连续内存保存元素；则结构体中需要可指向动态分配内存的*data记录栈顶下标 top 与当前容量 capacity 。 选内存策略 静态方案：定长数组（简单，但不可扩容）。 动态方案：calloc，可扩容，使用calloc必须free释放内存。 统一接口 创建、压栈、销栈、销毁。 处理“空”与“满” 空： top -1 满： top capacity-1 错误码返回值 C 语言没有异常，用 布尔Bool 返回操作成败； 打印 打印栈中的值。 代码展示#include stdio.h#include stdlib.h#include stdbool.h/*-------------------------- 类型定义 --------------------------*/typedef int ElemType; // 栈中元素类型，可一键改成其它基本类型typedef struct ElemType *data; // 动态数组，存放栈元素 int top; // 栈顶指针（指向当前栈顶元素，-1 表示空栈） int capacity; // 当前最大容量 SeqStack;/*-------------------------- 栈的创建 --------------------------*//* * 功能：创建一个空栈，可存放 size 个元素 * 返回值：栈管理结构指针，失败直接 exit */SeqStack *Stack_Create(int size) /* 1. 给管理结构本身申请内存 */ SeqStack *manager = (SeqStack *)calloc(1, sizeof(SeqStack)); if (!manager) // calloc 失败 perror(calloc); exit(EXIT_FAILURE); /* 2. 给真正存数据的数组申请内存 */ manager-data = (ElemType *)calloc(size, sizeof(ElemType)); if (!manager-data) perror(calloc); exit(EXIT_FAILURE); /* 3. 初始化成员 */ manager-top = -1; // 空栈 manager-capacity = size; // 记录容量 return manager;/*-------------------------- 入栈 --------------------------*//* * 功能：把元素 n 压栈 * 返回值：成功 true，失败 false（栈满或 manager 为空） */bool Stack_Push(SeqStack *manager, ElemType n) if (!manager) return false; /* 栈满判断：top 指向最后一个元素下标，容量为 capacity */ if (manager-top == manager-capacity - 1) printf(顺序栈已满，无法入栈 ); return false; /* 先移动栈顶指针，再写入数据 */ manager-data[++manager-top] = n; return true;/*-------------------------- 批量出栈 --------------------------*//* * 功能：连续弹出 cnt 个元素（只做逻辑删除，不返回元素值） * 返回值：成功 true，失败 false（栈空或 cnt 不合法） */bool Stack_Drop(SeqStack *manager, int cnt) if (!manager) return false; if (manager-top == -1) // 空栈 printf(顺序栈已空 ); return false; if (cnt manager-top + 1) // 请求弹出数 实际元素数 printf(弹出次数大于当前栈内元素个数 ); return false; /* 简单地把栈顶指针往下移，即完成“逻辑删除” */ for (int i = 0; i cnt; ++i) --manager-top; return true;/*-------------------------- 打印栈 --------------------------*//* * 功能：从栈顶到栈底依次打印元素 * 返回值：成功 true，失败 false */bool Stack_Print(SeqStack *manager) if (!manager) return false; for (int i = manager-top; i = 0; --i) printf(data[%d] = %d , i, manager-data[i]); return true;/*-------------------------- 销毁栈 --------------------------*//* * 功能：释放栈占用的所有内存 */void Stack_Destroy(SeqStack *manager) if (!manager) return; free(manager-data); // 先释放数组 free(manager); // 再释放管理结构/*-------------------------- 测试主函数 --------------------------*/int main(int argc, char const *argv[]) /* 1. 创建一个容量为 5 的顺序栈 */ SeqStack *s = Stack_Create(5); /* 2. 连续压入 5 个元素 */ Stack_Push(s, 10); Stack_Push(s, 20); Stack_Push(s, 30); Stack_Push(s, 40); Stack_Push(s, 50); /* 3. 打印当前栈（预期 50 40 30 20 10） */ Stack_Print(s); puts(); // 空行 /* 4. 弹出 3 个元素（只剩 20 10） */ Stack_Drop(s, 3); /* 5. 再次打印 */ Stack_Print(s); /* 6. 释放内存 */ Stack_Destroy(s); return 0; 这段代码最大的不足是“功能简陋且不安全”：它只做了最基本的固定容量栈，没有自动扩容、弹出的元素无法返回给调用者，离可复用、健壮的通用栈还差得较远，但可按照实际需要稍作修改还是能够实现顺序栈的基本功能。"},{"title":"使用c语言创建双向循环链表","path":"/2025/10/26/双向循环链表的创建/","content":"代码展示代码由本人所写，注释由AI生成仅供参考 本人学完了单向链表、单向循环链表、双向链表、双向循环链表，但个人觉得直接创建双向链表也能体现我所获得的知识，即在这个过程中本人除了写了单向链表的代码直接写双向循环链表来体现个人的积累 再次我还是推荐初学者还是认真手写一下各个链表内容，这对于自己的知识掌握还是很有作用的，也请记住在面对我们无法理解的知识，积累它总会有一天我们会弄懂的 /************************************** * file name:s2.c * author :17866044205@163.com * date :2025/10/26 * function :创建双向循环链表能够从头插入，尾插入，目标位插入包括删除也相同。 * note ：None * * CopyRig （c） 2025 17866044205@163.com All Right Reseverd * * ****************************************//* 双向循环链表 —— 完整注释版 * 编译：gcc dll_demo.c -o dll_demo */#include stdbool.h // bool 类型#include stdlib.h // calloc, free, exit, EXIT_FAILURE#include stdio.h // printf, perror, puts/* --------------- 类型定义 --------------- */typedef int DataType_t; // 数据域类型，可随意替换typedef struct Doubly_Circular_LinkedList // 链表节点 DataType_t Data; // 业务数据 struct Doubly_Circular_LinkedList *next; // 后继 struct Doubly_Circular_LinkedList *prev; // 前驱 LList_t;/* --------------- 创建空链表 --------------- *//* 返回一个带头结点的空双向循环链表。 * 头结点不存储有效数据，其 prev/next 均指向自己，表示“空”。 */LList_t *LList_create_Head(void) LList_t *Head = (LList_t *)calloc(1, sizeof(LList_t)); if (!Head) // 内存申请失败立即报错终止 perror(calloc); exit(EXIT_FAILURE); Head-prev = Head-next = Head; // 自环，空链表标志 return Head;/* --------------- 申请新节点 --------------- *//* 根据给定数据生成一个孤立节点，prev/next 先置 NULL。 */LList_t *LList_NewNode(DataType_t data) LList_t *New = (LList_t *)calloc(1, sizeof(LList_t)); if (!New) perror(calloc); exit(EXIT_FAILURE); New-Data = data; New-prev = New-next = NULL; return New;/* --------------- 头插法 --------------- *//* 把 data 插入到“第一个有效节点”之前，时间复杂度 O(1)。 */bool LList_HeadAdd(LList_t *Head, DataType_t data) if (!Head) return false; // 健壮性：空指针判断 LList_t *New = LList_NewNode(data); // 1. 造节点 if (!New) return false; /* 2. 四步插入（画图即明） */ New-next = Head-next; // 新节点连上旧首元 New-prev = Head; // 新节点连上头结点 Head-next-prev = New; // 旧首元的前驱改指新节点 Head-next = New; // 头结点后继更新为新节点 return true;/* --------------- 尾插法 --------------- *//* 把 data 追加到链表末尾，时间复杂度 O(n)（因需扫到尾）。 */bool LList_TailAdd(LList_t *Head, DataType_t data) if (!Head) return false; LList_t *New = LList_NewNode(data); /* 找到最后一个节点：其 next 指向 Head */ LList_t *cur = Head; while (cur-next != Head) cur = cur-next; /* 把 New 插到 cur 与 Head 之间 */ New-next = Head; // 新节点闭环 New-prev = cur; // 新节点前驱是旧尾 cur-next = New; // 旧尾后继更新 Head-prev = New; // 头结点前驱更新为新尾 return true;/* --------------- 按值前插 --------------- *//* 在第一个等于 Dest 的节点“后面”插入 data。 * 若 Dest 不存在则打印提示并返回 false。 */bool LList_DestAdd(LList_t *Head, DataType_t Dest, DataType_t data) if (!Head) return false; /* 从首元开始扫，直到回到头结点为止 */ LList_t *cur = Head-next; while (cur != Head cur-Data != Dest) cur = cur-next; if (cur == Head) // 扫完一圈没找到 printf(未找到目标值 ); return false; LList_t *New = LList_NewNode(data); if (!New) return false; /* 把 New 插到 cur 与 cur-next 之间 */ New-prev = cur; New-next = cur-next; cur-next-prev = New; cur-next = New; return true;/* --------------- 按值删除 --------------- *//* 删除第一个等于 Dest 的节点，成功返回 true，不存在返回 false。 */bool LList_DestDev(LList_t *Head, DataType_t Dest) if (!Head) return false; LList_t *cur = Head-next; // 从首元开始 while (cur != Head cur-Data != Dest) cur = cur-next; if (cur == Head) // 没找到 printf(未找到目标值 ); return false; /* 把 cur 从环中“摘”出来 */ cur-prev-next = cur-next; cur-next-prev = cur-prev; free(cur); // 真正释放 return true;/* --------------- 遍历打印 --------------- *//* 从头结点下一个（首元）开始，顺序打印所有有效数据。 */bool LList_Print(LList_t *Head) if (!Head) return false; LList_t *PHead = Head-next; // 首元 while (PHead != Head) // 回到头结点即停 printf(data = %d , PHead-Data); PHead = PHead-next; return true;/* --------------- 销毁整个链表 --------------- *//* 先释放所有数据节点，最后释放头结点，防止内存泄漏。 */void LList_destroy(LList_t *Head) if (!Head) return; LList_t *cur = Head-next; // 从首元开始 while (cur != Head) // 一圈扫完即止 LList_t *next = cur-next; // 提前保存后继 free(cur); // 释放当前 cur = next; free(Head); // 头结点最后释放/* --------------- 测试主函数 --------------- */int main(int argc, char const *argv[]) /* 1. 建表 */ LList_t *list = LList_create_Head(); /* 2. 尾插 30 40 50 */ LList_TailAdd(list, 30); LList_TailAdd(list, 40); LList_TailAdd(list, 50); /* 3. 头插 20 10 */ LList_HeadAdd(list, 20); LList_HeadAdd(list, 10); /* 4. 打印：预期 10 20 30 40 50 */ LList_Print(list); puts(); /* 5. 在 50 后面插入 60 */ LList_DestAdd(list, 50, 60); LList_Print(list); // 预期 10 20 30 40 50 60 puts(); /* 6. 删除 10(头) 30(中) 60(尾) */ LList_DestDev(list, 10); LList_DestDev(list, 30); LList_DestDev(list, 60); LList_Print(list); // 预期 20 40 50 puts(); /* 7. 销毁链表 */ LList_destroy(list); return 0; 个人感言双向循环链表和单向循环链表差别在于多了个前驱指针指向前一个存储块，但属于基本原理后双向循环链表并分比单向链表更加困难掌握链表只是学习过程中的第一步，总会有困难拦住你，而在我学习中也遇到了让我一度想放弃的困难，我是如何战胜它们的呢？我保持着沉默，我又去玩了一天什么都不做，然后我又回来了，继续挑战困难。这是一种感觉得自己品味才能明白，"},{"title":"计算机系统基础知识","path":"/2025/10/26/嵌入式系统设计师第一章/","content":"这是我阅读《嵌入式系统设计师》第一章所写的笔记以及知识概要，第一章讲的是计算机的基础知识，涉及的到了计算机各种器件、系统包括底层逻辑。 嵌入式计算机系统概述计算机硬件嵌入式计算机是以应用为中心，以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。 计算机硬件系统由运算器、控制器、储存器、输入设备、输出设备组成。 运算器和控制器以及相关部件集成一起称为中央处理单元：cpu。 运算器：对数据进行加工处理。 控制器：从主存取出指令进行分析。 储存器：分为内存（掉电丢失）、外存（掉电不丢失）。寄存器是cpu中的储存器件（储存少量数据，读取速度更快。） 数据表示进制转换 效验码 奇偶校验码 海明码在数据之间的特定位置插入k个校验位，通过扩大码距实现验错和纠错。 异或运算计算方式 算数运算计算机使用加法运算器，将两个数的补码相加。加上一个负数时，二进制数超过八位则自然丢弃。 溢出及判定两个补码相加时有可能会向第八位进1，但第八位是符号位，俩正数相加不可能得出负数。双符号位判决法、进位判决法 计算机组成及主要部件CPU的功能：程序控制、操作控制、时间控制、数据处理。CPU还会对系统内部和外部的中断（异常）做出响应。CPU构造图 运算器：算术逻辑单元、累加寄存器、数据缓存寄存器、状态条件寄存器组成。 控制器发出信号控制运算器。运算器不会自己产生程序。 算术逻辑单元（ALU）：处理数据对进行算术和逻辑运算。 累加寄存器（AC）：ALU的工作区“默认操作数和结果暂存桌”，减少CPU多次访问内存。 数据缓冲寄存器（DR）：暂时作为CPU与内存、外部设备数据传输之间的中转站，只能存一条指令或一个数据字。 状态条件寄存器（PSW）：存结果为零有进位溢出的状态，让 CPU 知道下一步该不该跳转。 控制器：指令控制逻辑、时序控制逻辑、中断控制逻辑。 指令控制逻辑：取指令、分析指令、执行指令。 指令寄存器（IR）：CPU将要执行的指令，从内存到数据缓冲寄存器，再到IR暂存，由指令译码器根据IR的内容产生各种微操作的指令，控制其他组件。 程序计数器（PC）：寄存信息和计数。 地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。 指令译码器（ID）：指令包含操作码和地址码，ID对操作码进行分析，识别该指令的规定操作。 时序控制逻辑：为每条指令按时间提供控制信息。总线逻辑是为多个功能部件服务信息通路的控制电路。中断控制逻辑用于控制各种中断请求，并根据优先级的高低对中断请求进行排队。 运算器和控制器中的寄存器都是专用寄存器。 储存器高速缓存Cache（容量小，贵，掉电丢失）：储存内存中CPU可能需要的数据，加快CPU运行时间。Cache地址影像为主存中CPU需要的数据提前找好座位。直接映像：主存中和Cache中的块对应关系是固定的。全相联映像：主存中任何一块数据都能放进Cache中的任意一个空位。组相联映像：分组时直接映像，组内全相联映像。虚拟储存器：对主存的抽象，MMU实现虚拟地址到物理地址的转换。外存储器：磁盘、光盘、固态。储存域网络：连接服务器与储存设备的网络。 总线计算机中的总线是指计算机设备和设备之间传输信息的公共数据通道。数据总线：双向传输数据。地址总线：单向传递CPU发出的地址信息。地址总线的宽度决定CPU的最大寻址能力控制总线：传输控制信号、时序信号、状态信号 南北桥芯片结构北桥芯片直接与CPU（通过前端总线）、内存（内存总线）、显卡（IO总线）、南桥相连，控制CPU的类型、主板的总线频率、内存控制器、显示核心等。南桥芯片：负责外部设备接口与内部CPU的联系（IO总线），如USB、ATA、SATA以及扩展接口。（包含多种设备的控制器、硬盘控制器、USB控制器、网卡、声卡控制器） 单芯片结构取消了北桥，CPU内置内存控制器，提高频率减少延迟。 常见总线ISA总线、EISA总线、PCI总线（其工作与CPU相互独立，PCI总线时钟与CPU时钟也是相互独立，PCI总线上的设备可以申请成为主控设备，与从属设备进行点对点的数据传输。还能对传输的地址和信号进行奇偶校验检测。 输入输出控制IO设备：电子芯片、导线、电源、电子控制设备、电机等组成的物理设备。 IO设备可分为块设备（将信息存放于独立的块中，可寻址，包括磁盘、USB闪存等）、字符设备（以字符为单位接收或发送一个字符串，不可寻址，包括打印机、网卡、鼠标键盘等） 设备控制器都有几个寄存器与CPU进行通信（通过寄存器发送或接收数据，和了解设备的状态）寄存器数量和大小有限，一般会RAM性质的缓冲区来存放数据。 RAM（随机存储器、主存、内存）：断电丢失数据、高速存取、随机访问、临时存储。 CPU如何与设备控制器中寄存器和数据缓冲区进行通信：1.\t为每个控制器分配一个IO端口，形成端口空间，并将信息储存于内存，由操作系统通过特殊指令和端口号来访问设备读取或是写入数据。2.\t将控制器的寄存器映射到内存空间，每个设备都有唯一的地址——内存映射IO。不需要特殊指令控制，可以使用C语言来编程。 程序控制方式无条件传送：外设无条件向CPU接收或发送数据。程序查询方式：通过CPU执行程序来查询外设的状态。 中断方式多中断信号线法：每个中断源都有属于自己的一根中断请求向CPU提供中断请求。 中断软件查询法：当CPU检测到了中断请求，立即转入中断服务程序去轮询每个中断源确实来源，对各个设备的相应由软件设定。 菊花链法：硬件查询法，所有IO模块共有一根共同的中断请求线，中断确认信号以链式在各个模块间相连，当CPU检测到中断请求信号时，则发出中断确认信号，中断确认信号依次在IO模块中传递，知道发出请求的模块，该模块把它的ID送往数据线由CPU读取。 总线仲裁法：一个IO设备在发出中断请求前，必须获得总线控制权，由总线仲裁来裁定谁可以发出中断请求信号，当CPU发出中断响应信号后该设备立即把自己的ID发往数据线。 DMA方式直接内存存取数据在内存与IO设备之间的直接成块传送，传输数据过程中不需要CPU干涉，CPU只需要发出开始或结束。DMA传送过程中，整个系统总线完全交给了DMAC，CPU不再使用总线。 输入输出处理机DMA出现方式减轻了CPU对IO操作的控制，使CPU效率提高。通道是是一个具有特殊功能的处理器，它分担一部分CPU功能，可以实现对外围设备的统一管理，完成外围设备与主存之间的数据传送。外围处理机，PPU是专用处理机，根据主机IO命令。完成对外设数据的输入输出 计算机体系结构计算机体系结构概述阿姆达尔：程序员要能编写出可以在机器上正确运行的程序必须了解概念性结构和功能特性。 梅尔斯：硬件与软件之间的界面，指令集体结构。 拜尔：体系结构由：结构（硬件互连）、组织（各种部件的动态联系与管理）、实现（各模块设计的组装完成）、性能（计算机系统的行为表现）。 计算机体系结构：计算机的概念性结构和功能特性。 计算机组织：计算机体系结构的逻辑实现，包括计算机内的数据流和控制流的组成以及逻辑设计。 计算机实现：计算机组织的物理实现。 计算机体系结构分类宏观：单处理系统、并行处理系统、多处理系统、分布式处理系统。 单处理系统：利用一个处理单元与外部设备结合实现储存、计算、通信、输入与输出等功能。 并行处理系统与多处理系统：将两个以上的处理器连接，协调通信，共同求解问题的计算机系统。 分布式处理系统：物理距离上远距离松耦合的多计算机系统。 微观（并行程度分类）：Flynn分类法、冯泽云分类法、Handler分类法、Kuck分类法 Flynn分类法：按指令流和数据流进行分类。单指令流、单数据流；单指令流、多数据流；多指令流、单数据流；多指令流、多数据流。 冯泽云分类法：按并行度（单位时间内处理的最大二进制位数）对计算机的系统进行结构分类。字串行位串行、字并行位串行、字串行位并行、字并行位并行 Handler分类法：基于硬件并行程度计算并行度的方法。 Kuck分类法：用指令流和执行流及其多重要性。类似于Flynn分类法 指令系统指令集体系结构：一个处理器支持的指令和指令的字节级编程。（不同处理器往往不通用） 指令集体系结构分类根据：操作数在CPU上的储存方式、显示操作数的数量、操作数的位置、指令的操作、操作数的类型与大小。 按暂存机制分类可将指令集体系分为：堆栈、累加器、寄存器组。 通用寄存器：寄存器提供更灵活的次序，能够储存变量。 CISC和RISC复杂指令集计算机（CISC）：增强原有指令的功能，用更复杂的新指令替换原先由软件程序完成的功能。 弊端：1.\t指令集过于庞杂。2.\t需要用多个CPU周期运行解释性微程序来执行复杂指令。3.\t高级语言编程程序选择目标指令范围很大，难以优化。4.\tCISC强调完善的中断控制，导致动作繁多、设计复杂、研制周期长。5.\tCISC增大芯片种类、出错率提高，成品率降低，成本提高。 精简指令集（RISC）：减少指令总数和简化指令功能、降低硬件设计复杂度，优化编译提高指令执行速度，采用硬布线控制逻辑优化编译程序。 RISC关键技术：1.\t重叠寄存器窗口技术：在处理器中设置数量较大的寄存器堆。2.\t优化编译技术：RISC使用大量寄存器，通过编译技术的优化来实现合理分配寄存器，提高寄存器的效率减少访存次数。3.\t超流水及超标量技术：进一步提高流水线速度。4.\t硬布线逻辑和微程序相结合在微程序技术中。 优化静态使用频率：对程序中出现的各种指令以及指令串进行统计得到的百分比。 按静态使用频率来改进目标代码，可减少程序所占的储存空间。 动态使用频率：在程序执行过程中各种指令以及指令串进行统计得到的百分比。 按动态是使用频率来改进目标代码，可减少程序运行的执行时间。 面向高级程序语言的优化思路是减少高级语言与机器语言之间的语义差距。 面向操作系统的优化思路是减少操作系统与体系结构之间的语义差距。 指令的流水处理指令控制方式：顺序方式、重叠方式、流水方式。 顺序方式：各条机器指令包括内部微操作按顺序串行执行，缺点速度慢、机器各部件利用率低。 重叠方式：在执行第K条指令就开始分析第K+1条指令。速度提高、易冲突。 流水方式：并行性或并发性嵌入计算机的一种形式。将重复的顺序处理过程分解为若干字过程，每个字过程都能在专用模块上有效的并发工作。 如分为取指令、指令译码、取操作数、执行，将机器指令并发在这几种模块上处理。1.\t级别：部件级、处理机级、系统级。2.\t功能：单功能流水、多功能流水。3.\t连接：静态流水线、多功能流水线。4.\t反馈回路：线性流水线、非线性流水线。5.\t流动顺序：同步流水线、异步流水线。6.\t数据：标量流水线、向量流水线。 流水的相关处理：对同一寄存器先写后读会出现指令相关、访存操作数相关、通用寄存组相关等，影响相关的两条或几条指令，也被称为局部相关。 推后法：推后相关单元的读，直至写入完成。 通路法：设置相关专用通路，先把运算结果写入相关储存单元。 全局性相关：不能同时解释转移指令，执行转移指令，可能会改变指令缓冲器中预取到指令内容，造成流水线的吞吐率（单位时间内流水线处理机流出的结果数）和效率下降。 猜测转移分支、加快和提前形成条件码、加快短循环程序的处理 RISC采用的流水技术超流水线：增加级数提高主频，以时间换空间。CPI（指令需要的机器周期数稍高。超标量技术：内装多条流水线同时执行多个处理，以空间换时间。超长指令字技术：充分发挥软件作用，使硬件简化，性能提高，需要足够高的时钟频率 阵列处理机、并行处理机、多处理机 可靠性与系统性能评测基础知识元器件可靠性的三个阶段开始阶段：不稳定失效率较高。第二阶段：正常工作期。第三阶段：老化期 计算机的可用性用正常工作的概率A表示 两次故障之间系统能正常工作时间的平均值MTBF 计算机的可维修性平均维修时间MTRF AMTBFMTBF+MTRF 计算机的RAS：可靠性R、可用性A、可维修性S 计算机可靠性模型 N模冗余系统：由N个（2n+1）相同的子系统和一个表决器组成，以N个系统中的多数输出作为系统输出. 提高计算机的可靠性1.\t提高元器件质量，改进加工工艺与工艺结构，完善电路设计。2.\t发展容错技术，使计算机在有故障的情况下依旧能工作。 计算机系统的性能评价性能评测的常用方法：时钟频率、指令执行速度、等效指令速度法、数据处理速率、核心程序法。 准测试程序整数测试程序：测试编译器、CPU处理整数指令、控制功能的有效性。 浮点测试程序：测试浮点计算能力。 1.理论峰值浮点速度（MFLOPS）：测试机器在理论上最大能完成的浮点计算速度。 2.Linpack基准测试程序：让机器运行Linpack程序来测量MFLOPS。 3.Whetstone基准测试程序：执行浮点运算、整数算术运算、功能调用、数组变址、条件转移和超越函数的程序组成。 SPEC基准程序：被测计算机的执行时间标准化，被测计算机的执行时间除以一个参考处理器的执行时间。 TPC基准程序：衡量机器性能以及性能价格比。"},{"title":"C语言核心内容总结","path":"/2025/10/25/C语言核心内容总结/","content":"距离学完C语言核心内容已过半月、是时候总结一下我的学习成果了，在过去的半月中、曾一度面对困难想要逃避放弃，但积累的成果告诉我，我已经做了这么多了，那些曾经棘手的问题都已经转换成了我积累的一部分了。 C语言核心内容笔记 核心关键字32 个关键字auto break case char const continue default dodouble else enum extern float for goto ifint long register return short signed sizeof staticstruct switch typedef union unsigned void volatile while 第一档 ：int 整型类型关键字，声明整数变量、函数返回值。return 函数返回语句，结束函数并带回结果。if （else） 条件判断for 计数循环最常用。while 条件循环。break 跳出当前循环或switch。continue 跳过本轮循环剩余语句。switch 多路分支。case switch 的分支标签。default 处理switch中为被case标签匹配的情况。void “空”类型，函数不返回值或指针不带类型。sizeof 编译期求类型对象字节数 第二档：char 字符／最小整数类型。float 单精度浮点。double 双精度浮点。long 加长整型short 短整型。signed unsigned 有符号／无符号修饰符。const 只读修饰符，编译期阻止修改。static 两种用法： 1. 函数内部——静态存储期，只初始化一次。 2. 函数文件外部——内部链接，只对当前文件可见。extern 声明标识符“定义在别处”，跨文件引用全局变量函数。struct 结构体，聚合类型之王。union 联合体，同一内存 overlay 多种类型。enum 枚举，给整型常量起名字。typedef 给已有类型起新名字，造“别名”。volatile 告诉编译器“该对象可能异步改变”，禁止优化。 第三档auto 函数内局部变量默认就是 auto，写不写都一样。do do{…}while(); 循环，至少执行一次。goto 无条件跳转，能不用就不用。register 建议编译器把变量放寄存器，现代编译器基本忽略。 内存管理学习c语言一定要联系计算机背后的运行逻辑，而其与计算机中的内存管理最为重要 保留区作用捕获“空指针解引用”和“小偏移量野指针”为内核 vsyscall、vsyscall32、vdso 等保留固定映射页属性：不可访问 代码段内容： – 所写的函数体、编译器生成的辅助函数。 – 模块初始化函数（**init）在 Linux 内核被收集到 .init.text，启动完后内核会把这块回收。属性：可读可执行，不可写。生命周期：随进程一直存在；内核模块的 .init.text 在初始化结束被 free_init_pages() 释放。 数据段rodata编译器把字符串、跳转表等单独放进 .rodata，只读数据段防止映射成可执行页。内容：字符串字面量、const 全局变量、switch 跳转表、printk 的格式串…… 已初始化数据段Data内容： – 全局变量、文件作用域变量、static 局部变量，且你在源码里给了初值。 – 内核的 **initdata，启动后同样会被回收。属性：可读可写，不可执行。 未初始化数据段BSS内容：全局static 变量未显式赋初值（或初值为 0）属性：可读可写，不可执行。 堆内容：malloccallocnew、realloc、free 管理的对象；内核的 kmalloc(vmalloc) 区。增长方向：向高地址伸展。属性：可读可写，可执行堆需显示（高危操作）。生命周期：程序员显式释放或进程退出时内核统一回收。 栈内容： – 函数调用的返回地址、参数、局部变量、寄存器保存区。 – 编译器生成的临时数组、VLAs、alloca()。内容：增长方向：向低地址生长属性：可读可写，不可执行。生命周期：线程创建时分配，线程退出时回收；主线程随进程一起消失。 动态内存管理malloc、calloc都是向“堆（heap）”申请一块连续内存的标准库函数，不会被自动回收，需要手动释放。本身属于 libc 的 text（代码段）；它们返回的那块空间才属于 heap（堆）。 #include stdlib.hvoid *malloc(size_t size); // 申请 size 字节，内容不确定void *calloc(number, size_t size); // 申请 number 块，每块size字节 ，全部清 0//返回值：成功返回指向首字节的 void * ，失败返回 NULL 。所以必须做 NULL 检查！ calloc与malloc的优缺点：1.calloc 内部会检测 number*size 是否溢出；而 malloc 不会，使用malloc必须做溢出处理。2.申请大块内存 calloc会把每一页刷成 0，所以比malloc慢。如果随后需要自己再写一遍，不如直接 malloc +手动赋初值。3.无论是 malloc 还是 calloc ，都必须用 free(ptr) 释放一次且仅一次。 memsetmemset 是 C 标准库 string.h 里最常用的“内存填充”工具函数把从地址a开始的n个字节，全部设置为同一个字节值b。 #include string.hvoid *memset(void *a, int b, size_t n); memset的典型用法1.清零 int a[100];memset(a, 0, sizeof a); // 整个数组变 0 2.置1字节 unsigned char buf[64];memset(buf, 0xFF, sizeof buf); // 每个字节 0xFF 3.初始化为某个字节 char str[32];memset(str, *, sizeof str - 1);/* 31 个 * */str[31] = \\0; // 手动补字符串结束符 、 错误处理防御性编程定义：种主动预防错误的编程策略，强调在代码中提前识别并处理潜在问题，避免因外部输入、异常状态或并发操作导致系统崩溃核心假设 ：输入总是错误的- 外部依赖不可靠- 代码本身可能有 bug目标 ：提高系统的健壮性、可维护性、容错能力，降低故障蔓延风险。 Segmentation（段错误） 根本原因：访问了无权或无效的虚拟地址1.解印引用NULL2.野指针悬垂指针3.越界访问4.缓冲区溢出覆盖返回地址5.对字符串常量区写入6.函数返回局部变量地址 总结学习c语言没有完成时，只有提高我们的逻辑思维不断的增加c语言相关知识，才能够编程出更精简更出色的代码。学习了c语言的知识就该知道如何使用它们，在使用的过程中接触新的内容，融会贯通，才能在编程的道路上越走越。"},{"title":"使用c语言创建顺序表","path":"/2025/10/22/顺序表的创建/","content":"本篇文章是我学习数据结构过程中，共花费4个小时实现顺序表创建的c语言代码，学完c语言后第一次完全由自己从零到一写完代码的过程，在学习过程中总会遇到当前阶段难以挑战的困难，我也在学习数据结构的过程中几次逃避，但是‘积累’给我带来面对挑战的勇气，长期的积累就是我不服输的底气。 代码展示// 引入3个头文件：布尔类型、通用工具、标准输入输出#include stdbool.h#include stdlib.h#include stdio.htypedef int DataType_t; //可替换数据类型/* 顺序表结构体定义 */typedef struct SequenceList int * Addr; // 指向真正存放数据的动态数组 unsigned int MaxSize; // 数组最大容量 int Last; // 当前最后一个元素的下标（空表时为-1） SeqList_t;/* 创建一个容量为size的顺序表，返回管理体指针 */SeqList_t * SeqList_Create(unsigned DataType_t size) // 给管理体本身申请一块清零的内存 SeqList_t *Manager = (SeqList_t *)calloc(1, sizeof(SeqList_t)); if (NULL == Manager) // 管理体内存申请失败 printf(为管理体分配内存失败 ); exit(-1); // 直接终止整个程序 if (0 = size) // 容量不合法 printf(创建的顺序表尺寸不能小于1 ); exit(-1); // 给数据区申请size个int的清零空间 Manager-Addr = (DataType_t *)calloc(size, sizeof(int)); if (NULL == Manager-Addr) // 数据区内存申请失败 printf(为管理体指向Addr的储存区分配内存失败 ); free(Manager); // 先释放已申请的管理体 exit(-1); Manager-MaxSize = size; // 记录最大容量 Manager-Last = -1; // 初始为空表 return Manager; // 返回管理体指针/* 判断顺序表是否已满 */bool SeqList_IsFull(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last + 1 == Manager-MaxSize); // 满返回true，否则false/* 判断顺序表是否为空 */bool SeqList_IsEmpty(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last == -1); // Last为-1表示空表/* 头插：把data插入到表头（下标0位置） */bool SeqList_HeadAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; // 把原有元素整体后移一位 for (int i = Manager-Last; i = 0; --i) Manager-Addr[i + 1] = Manager-Addr[i]; Manager-Addr[0] = data; // 新元素放入头部 Manager-Last++; // 更新Last return true;/* 尾插：把data追加到表尾 */bool SeqList_TailAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; Manager-Addr[++Manager-Last] = data; // 先Last+1，再写入数据 return true;/* 按值删除：删除第一个等于data的元素 */bool SeqList_Del(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表无法删除 printf(顺序表为空，无法删除 ); return false; int i = 0; // 找到第一个等于data的元素下标 while (Manager-Addr[i] != data i = Manager-Last) i++; if (i = Manager-Last) // 找到了 // 把后面元素整体前移一位覆盖掉被删元素 while (i Manager-Last) Manager-Addr[i] = Manager-Addr[i + 1]; i++; Manager-Last--; // 元素个数减1 return true; // 没找到 printf(此顺序表中没有找到你指定要删除的数 ); return false;/* 打印整个顺序表 */bool SeqList_Print(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表提示 printf(元素为空无法打印 ); return false; // 逐个元素打印 for (int i = 0; i = Manager-Last; ++i) printf(Addr[%d]=%d , i, Manager-Addr[i]); return true;/* 销毁顺序表：先释放数据区，再释放管理体 */void SeqList_Destroy(SeqList_t *Manager) if (!Manager) return; // 空指针直接返回 free(Manager-Addr); // 释放数据区 free(Manager); // 释放管理体/* 主函数：简单测试 */int main(int argc, char const *argv[]) // 创建一个容量为5的顺序表 SeqList_t *list = SeqList_Create(5); // 尾插5个元素 SeqList_TailAdd(list, 10); SeqList_TailAdd(list, 20); SeqList_TailAdd(list, 30); SeqList_TailAdd(list, 40); SeqList_TailAdd(list, 50); SeqList_Print(list); // 打印当前表 printf( ); // 删除3个元素 SeqList_Del(list, 10); SeqList_Del(list, 30); SeqList_Del(list, 50); SeqList_Print(list); // 再次打印 SeqList_Destroy(list); // 用完销毁 return 0; 当然作为一个初学者我所写的代码还存在着可以优化的地方，但从逻辑上来分析我所写代码的优势就在于逻辑清晰。放在学生作业、嵌入式底层库中、面试笔试场景中都有不少亮点。 代码优势1.结构设计： 我将管理元数据与数据区彻底分离。2.接口语义清晰： 我大部分函数都使用的bool返回，失败false、成功true，语义单一。3.可裁剪性高： 没有任何全局变量静态变量。4.精确的错误信息： 每条错误都带由中文提示。5.空指针的保护密度： 每个接口都做了 if (!Manager) return false;。6.初始化策略： 选择使用calloc，使用malloc需要手动添加memset。7.数据类型： 可以更改数据类型，提高了泛型能力。 代码缺点 内存申请失败直接 exit，把库变成了进程杀手，嵌入式或插件场景根本没法优雅降级。 容量固定，没有扩容接口，浪费内存。 头插和删除用循环搬数据，O(n) 最坏复杂度。 按值删除只清掉第一个匹配项，想全删得外层再套循环，时间平方级。 只有头插尾插，没有按位置插入，用户想往中间放元素只能自己拼“删了再插”的野路子，还是 O(n²)。 没有 FindIndexOf 这类只读定位，判断存在性只能裸翻内存或打印人肉搜索，封装性被击穿。"},{"title":"2025年9月-10月总结","path":"/2025/10/18/2025年9月-10月总结/","content":"这是我2025年至2026年的规划，截至至2025年10月18日我已经学完了c语言，预计至10月25日学完嵌入式该具备的数据结构知识。为应对软件考试：嵌入式系统设计师，我也在阅读《嵌入式系统设计师教程》，预计明年报考。 c语言部分笔记展示 阅读《嵌入式系统设计师教程》部分笔记 深入学习了计算机的基础知识，计算机的包括组成结构，运行逻辑以及原理。对计算机的重要部件进行了研究。 数据结构部分笔记展示 数据结构与c语言紧密结合，既有对c语言代码运行的底层逻辑，对程序运行中涉及到的各个器件、内存都必须要有深刻的了解。 总结 这是我的第一篇博客，今后我会将我的各个阶段的总结、成果、笔记上传至此博客，既是对我个人的积累，也是希望我所分享的内容能为他人带来帮助。"}]