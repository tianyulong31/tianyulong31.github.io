[{"title":"自举模式的选择","path":"/2025/11/13/自举模式选择/","content":"学习使用STM32会写代码反而不是重点，重点是会看懂各种手册，包括参考手册、数据手册等等，国内的中文手册大多都是机翻，翻译会出现一些不准确的用词，继而学会英语能提高在这个行业上的高度，但今天重点不是这个，而是如何去了解STM32相关芯片 本文以STM32F10x为例 自举配置此图片的启动配置实际上是自举配置译者应该是把Bootstrap翻译成了启动 引脚：引出来的管脚BOOT[1:0]引脚决定选择三种不同的自举模式BOOT[1:0]有两个引脚：BOOT0引脚、BOOT1引脚 此图是STM32F10x数据手册中48引脚芯片 BOOT0是44号引脚 BOOT1是20号引脚，BOOT1 引脚（PB2）在启动时具有特殊功能，启动完成后可恢复为普通 GPIO 使用找BOOT0和BOOT1不应该在开发板去找，而是看原理图，一般数据手册和参考手册上没有原理图 上图为BOOT的原理图，在开发板上一般包括两个跳线帽跳线帽可作用于引脚短接，一个条线帽容纳两个排针 GND 地 （负极0V）、 VCC 电源（正极3.3V） 、VDD也是电源 STM32F103C8T6的6个排针是 0 boot0 10 boot1 10接地，1接电源（接VCC，通电状态，用逻辑1表示） 上图的自举配置中 BOOT1下的x表示可以接1也可以接0 自举中的三种模式1.主Flash模式，选择Flash作为自举空间闪存容量是64KB，闪存存储器属于ROM的一种掉电不丢失数据闪存有使用寿命，原理：黑板原理，先擦除再写入，可以反复擦除十万次左右如果把程序下载到Flash中并且打算从Flash中启动程序，则需要让CPU跳转到0x08000000这个地址下开始执行 大小为：块扇区编程页字节如图以STM32F103C8T6为例Flash容量为64KB则共有64页，且每次擦拭是按页擦拭的 2.系统存储器如图大小为2KB，一般无法向其中存数据，是芯片厂商使用的，是厂商提供的启动引导程序BootLoader必须借助厂商提供的工具下载程序，一般都是采用串口实现程序下载，但偶尔会导致芯片锁死 3.嵌入式SRAM（静态随机访问存储器） STM32F103C8T6芯片内部的SRAM的大小是64KB，特点掉电丢失调试时可以下载到SRAM中使用 一般使用主Flash就够用了即BOOT0接0，BOOT1也接0 复位电路接好后需要复位，一般标记的RESET为复位按键 复位电路的原理图复位电路必背，芯片的复位引脚需要低点平复位，电容作用：充电放电特性。电阻作用：给电容充电原理：VDD3V3给电容充电一直保持复位引脚为高电平，触摸按钮后电流不再经过电容，电容放电（过程很短）复位引脚接收低电平 两种情况：1.开始按复位，下载程序，开始执行程序2.下载程序，按复位，开始执行程序 一般采用TTL电平协议来表示一个管脚的状态"},{"title":"通用输入输出接口和模块数模接口","path":"/2025/11/12/嵌入式系统设备接口/","content":"嵌入式系统是面向应用，不同的应用所用的接口和外设不同。接口是CPU和IO设备之间交换信息的媒介和桥梁，CPU和外部设备、存储器的连线和数据交换都需要通过设备接口来实现 通用输入输出接口同用输入输出接口是是一组输入引脚或输出引脚，CPU能够对它们进行存取，并且有些引脚可以可以通过编写改变工作方向 双向GPIO端口的简化功能逻辑图 DDR数据方向寄存器：设计端口的方向。该寄存器输出为1，则端口为输出，输出为0，则端口为输入若想要改变DDR，则需将恰当的值置于D0，同时激活WR_DDR信号读取DDR单元的状态，同时激活RD_DDR信号 若PORT引脚置为输出，由PORT寄存器控制该引脚状态，若将PORT引脚设置为输入，则此输入引脚状态由引脚上的逻辑电路层来实现对它的控制对PORT寄存器的的写入，将激活WR_PORT信号 DDR和PORT寄存器都映射到微控制器的地址空间 模块数模接口、1.数模转换接口（AD转换器）AD转换器就是把电模拟量转化成数子量的电路 实时监测系统和实时控制系统都离不开模数转换器1.在实时控制系统中传感器把实时现场的各种信号（温度、流量、压力、PH值、位移）测量出转换成对应的电信号2.通过各种方式处理电信号后送到AD转换器，由其将电信号转换成数字模拟量信号3.微机采集后按照一定算法输出控制量，再输出数据经过DA转换器去控制执行机构 实现AD转换的方法有：计数法、双积分法和逐次逼近法 在这里嵌入式系统设计师教程和实际工业模型不一样1）计数法1.每次转换开始前，积分器把电容放电为0，计数器复位2.计数器准备计数，计数器输出数字为0，0送至DA转换器输出0V模拟信号3.比较器输入带转换的模拟输入电压Vi大于V0（0V）使计数控制信号C为14.计数器开始计数，从DA端得到的数字量不断增加，致使输出电压Vo也不断上升5.VoVi时，比较器输出低电平，使计数器控制信号为0，计数器停止计数6.计数控制信号有高到低的负跳通知计算机完成一次AD转换 2）双积分法1.基本原理是对模拟电压和参考电压进行两次积分2.得出输入电压均值成正比的时间间隔，利用时间间隔和计数器测出其时间间隔3.此类的DA转换器具有较强的抗干扰能力，转换精度高，速度较慢，适用于数字式测试仪表、温度测量等4.步骤：对待测的模拟电压进行固定时间的积分，然后换至标准电压进行固定斜率的反向积分，反向积分至一定时间，返回起始值。对标准电压进行反向时间T正比于输出模拟电压，输入模拟电压越大，反向积分回到起始值时间越长。即只要用标准的高频时钟脉冲测定反向积分花费时间，可得到相应于输入模拟电压的数字量，实现AD转化 3）逐次逼近法逐次逼近式AD转换于计数法转换大致一样。它通过DA转换器从高位到低位逐次增加转换位数，产生不同的输出电压，将输入电压与输出电压进行比较而实现不同之处在逐次逼近式使用了一个逐次逼近寄存器存放转换出来的数字量，转换结束时将数字量送至缓冲寄存器 数模转换接口通常采用T型网络实现将数字量转换成模拟电流，然后再用运算器放大器完成模拟电流到模拟电压的转换。目前大部分AD转换器都集成了这两个环节但对只包含第一个环节的AD转换器就需要额外配置运算器和放大器完成转换"},{"title":"高速缓存与其他存储设备","path":"/2025/11/11/高速缓存与其他存储设备/","content":"本文为嵌入式系统设计师教程相关阅读笔记，记录学习内容以便后来查看以及分享我的学习积累 高速缓存Cache位置：位于处理器和外部内存之间速度比RAM更快的存储器一般称之为高速缓存器 当处理器执行程序时需要不断的访问内存，而读取内存的速度比CPU慢，严重制约系统实际性能 CPU总是访问当前内存地址的相邻地址，符合局部性访问原理，基于此原理通过在CPU和外部存储器之间设计高速缓冲器，可使CPU进行外部存储设备的局部存储，可提高对CPU对外部存储设备的访问效率。 Cache的主要作用：对外部存储设备的缓冲Cache的组成：内部由块号和块内偏移组成原理：(1)Cache收到CPU访问内存地址 (2)Cache将CPU访问内存的地址分解为块号和块内偏移 (3)利用分解的块号查找Cache内部的Cache块 (4)通过（3）找到一个即为命中，再用块内偏移区索引该块中的数据：当前是读内存即可立即将Cache中缓存的数据返回给CPU；如果是写操作：1）Write-Through（写直达）动作：数据同时写入Cache和主存优点：数据一致性高，主存始终是最新的缺点：写操作慢，因为每次都要写入主存2）Write-Back（写回）动作：数据写回Cache，不立即写入主存，当Cache行替换时才写回主存优点：写操作快，减少主存访问次数缺点：数据一次性差，主存数据不是最新的3）Write-Allocate（写分配）动作：写操作时，若数据不在Cache中，先将数据加载到Cache中再写入通常与Write-Back搭配使用优点：后续写操作可以命中Cache缺点：首次写操作需要额外一次读操作4）NO-Write-Allocate（非写分配）动作：数据不在Cache中直接写入主存，不加载到Cache通常与Write-Through搭配使用 例子：采用Write-Back（写回）和Write-Allocate（写分配）写入一个地址，如果Cache命中，只写Cache，标记为dirty写入一个地址，如果Cache不命中，先从主存加载该地址的数据到Cache，然后再写入Cache，并标记为dirty当该Cache行被替换时，才会把dirty数据写回主存 (5)如果未命中，Cache首先查找内部Cache内部有没有空闲块，若找到了空闲块，就在该块中装入CPU访问内存地址对应的内存块，若是读内存操作就把这个地址对应的数据返回给CPU，写入操作根据类型不同，动作也不同 (6)如果没有找到空闲块，则需要使用Cache管理中的块替换策略，找到Cache中可替换出去的块，如果是读内存操作，那么根据替换块的块号和状态，Cache会决定是否把这个块写刀内存中，同时把这个地址对应的数据返回给CPU，写入操作根据类型不同，动作也不同 Cache出现命中和不命中的原因： Cache 只是主存的一小部分“副本”，不可能把全部内存都装进去，所以任何映射策略都必然出现 现代计算机默认路径是Cache，CPU读取内存任何数据都会经过Cache但机器里还有大量刻意绕过 Cache 的区间：1.内存映射 IO（MMIO）、PCIe BAR、显卡帧缓冲2.DMA 共享环形缓冲区、网卡描述符队列3.由驱动标记为 UCWC 或 ARM DeviceGreedy 的页这些区域 CPU 一访问就直接走内存总线，不进任何 Cache 层次 Cache的重要作用Cache通过提高CPU访问效率来缓解CPU和内存之间的速度不匹配 Cache的工作机制示意图 其他存储设备1.快闪存储器（FLASH）简称闪存，闪存的大部分芯片需要块擦拭，正因为写入速度较快，所以称为闪存 FLASH分为两类；NOR FLASH和NAND FLASH（1）NOR FLASH任何FLASH的写入操作只能在空或已擦拭的单元内进行，即在写入操作前必须进行擦拭，NOR FLASH在擦拭前把先将目标块内所有位都写为0NOR FLASH带有SRAM接口，易存取其内部每一个字节，可直接连接系统总线构成内存储器 （2）NAND FLASHNAND器件使用复杂的IO口来串行的存取数据，但不能构成内存，只能构成外存储器NAND的读和写操作一般采取512字节的块 两者对比1.NOR的读速度比NAND快，但NAND的写入速度远比NOR快2.NAND的擦拭速度远比NOR的快，因为NAND的擦拭单元更小，擦拭电路更少3.NOR FLASH上可直接运存程序，NAND FLASH只能存储信息 2.磁盘、光盘等存储介质 1）磁盘磁盘存取速度都最快、具有较大的存储容量 磁盘存储器是由盘片、驱动的器、控制器和接口组成1.盘片的两面用来存储信息2.驱动器控制数据的写入和读写3.控制器接收主机发出的命令，控制磁盘驱动器写入和读写，实现主机与其的数据转移和传送4.接口是主机和磁盘存储器之间的连接逻辑 磁盘也被称为硬盘存储器，其作用原理和组成大致相同硬盘驱动器内使用了多个盘片，提高了存储器的存储容量 硬盘的接口方式决定了硬盘的性能常见的接口有IDE（ATA）和SCSI，还有一些采用PCMCIA或USB接口IDE用于普通用户SCSI用于服务器等高端应用场合 2）光盘利用磁头变化和磁头电流进行读或写 3）CF（Compact FLASH）IDE接口的固态硬盘，块存耐震大容量，针脚多、体积大 4）SD（Secure Digital Memory Card）基于半导体快闪记忆器，重量轻、高记忆容量、快速数据传输、极大的移动灵活性和很好的安全性"},{"title":"STM32开发板概述","path":"/2025/11/06/嵌入式概述/","content":"国内定义：嵌入式就是以应用为中心，以计算机技术为基础，软硬件可裁剪，适用于对于体积、可靠性、功耗、性能等方面严格要求的专用计算机系统。 微控制器的关系现在的市场需求：成本低、性能高、功耗低、多任务、易用界面 基于市场需求ARM公司 ARM公司的开发 学习STM32的原因STM32系列介于低端和高端芯片之间，相较于低端芯片STM32拥有强大的内核架构、更多的片上外设、可以运行uCOS、freeRTOS等实时操作系统，相较于高端芯片STM32成本更低、实时性较强。所以学习STM32是大多数嵌入式开发人员的必经之路。 学习STM32不仅仅对相关外设（串口、定时器等）进行学习，而是要掌握软件的设计流程，这样在设计一款产品的时候才知道如何进行器材选择、协议选择、数据格式等，并且大多数的产品都会搭载实时操作系统，所以也要掌握实时操作系统设计架构和使用方法。 STM32的应用领域STM32属于微控制器MCU，自带各种通信接口 1.工业 电机控制（FOC、伺服）、PLC、工业网关、机器人、数控、智能传感器、电源管理（数字电源、UPS）。 汽车 车身控制（BCM、车窗、座椅、车灯）、BMS、车载充电器、数字仪表、T-Box、ADAS 边缘节点、E-bikeEV 小电机。 消费 手机PC 外设（触控板、摄像头模组、快充协议芯片）、可穿戴（手环、手表）、平衡车、电子烟、玩具、小家电（空调、冰箱、洗衣机、咖啡机）。 物联网与边缘计算 智能表计（水、电、气、热）、资产追踪、智能门锁、烟感、Beacon、Sub-GLoRa、Wi-Fi、BLE、Cat-1NB-IoT 模组的主控或协议栈 SoC。 医疗与保健 便携血氧仪、血压计、胰岛素泵、一次性内窥镜、健身设备、心电贴片。 图像与音视频 扫码枪、条码二维码识别、微型打印机、电子词典、教育点读笔、USB-C 耳机、麦克风阵列。 航空航天与国防 小型无人机飞控、卫星姿控、火箭地面测试设备、导弹舵机、单兵设备（低功耗、抗辐射型号）。 教育 高校嵌入式教学、开源硬件（Arduino 兼容板）、竞赛、创客项目、RT-ThreadFreeRTOS 实验平台。 就业前景STM32 并非终局，而是嵌入式职业路径中的关键过渡技术节点。 其生态完备、迭代连续，在可预见的 10 年周期内仍将为不同计算平台提供硬件抽象与实时控制基准。 2025 年产业缺口集中于“以 STM32 为起点，具备向 Linux、边缘 AI 或车规级架构跃迁能力”的复合型人才；跃迁幅度直接决定薪酬分位，市场对能完成技术栈纵向扩展者的定价显著高于单一 MCU 开发者。 STM32开发方式主流的三种开发方式：函数库开发、寄存器开发、图形界面开发 （1）STM32 寄存器开发 STM32的资源外设比较丰富，所以导致寄存器的数量增多并且复杂度增大，要求开发人员掌握底层开发的相关知识。 一般情况涉及实时性要求较高，频繁调用的中断服务函数才会直接使用寄存器开发。 （2）库函数开发 ST公司开发了两套库标准外设库、HAL库。目前标准外设库已经停止维护，但是目前绝大数公司依旧采用标准外设库进行项目开发。 STM标准外设库是ST公司专门针对STM32提供一系列API（函数接口），用户可以调用这些函数来配置STM32底层的寄存器，有利于快速开发和维护。 库是架设在寄存器和用户代码之间的代码，向下与寄存器相关，向上提供用户相关接口。 （3） 图形开发 ST公司设计都图形界面软件（STM32CubeMX）自动生成代码，用户只需要根据实际需求选择相应参数，即可 自动生成初始代码，极大提高开发效率"},{"title":"树","path":"/2025/11/03/数据结构“树”的知识点/","content":"树的概念节点（Node）-树中的每个元素。根节点（Root）-树的起点。叶子节点（Leaf）-没有子节点的节点深度：从根到该节点的路径长度。度-一个节点的子节点个数 树的分类满二叉树所有非叶子节点都有两个子节点，且所有叶子在同一层。完全二叉树除最后一层外，其他层都是满的，且最后一层从左到右填充。二叉搜索树左子树所有节点 根 右子树所有节点（中序遍历有序）。平衡二叉树BST 的左右子树高度差不超过1，保证 O(log n) 操作。红黑树自平衡 BST，通过颜色标记和旋转保持平衡（Java TreeMap、C++ STL 使用）。哈夫曼树带权路径长度最短的二叉树，用于数据压缩。线索二叉树利用空指针存储前驱后继，加速遍历。 树的遍历方式前序遍历（根 → 左 → 右） 中序遍历（左 → 根 → 右） 后序遍历（左 → 右 → 根） 树的应用文件系统 -目录结构是 N 叉树。数据库索引 -B 树、B+ 树用于磁盘索引（如 MySQL）。编译器 -语法树（AST）表示程序结构。压缩算法 -哈夫曼编码用哈夫曼树。路由协议 -默克尔树（Merkle Tree）用于区块链数据验证。优先队列 -堆（完全二叉树）实现优先级队列。 关于树的相关试题11.步骤一：寻找根节点步骤二：根据前序遍历和中序遍历的特点即可推出二叉树步骤三：后序遍历13.后序遍历e后直接是a（根节点）所以只有一个孩子节点a。假设二叉树采用二叉链式储存结构，设计一个算法，计算一棵给定二叉树的所有节点 int NodeCount(BiTree T) if (T == NULL) return 0; return 1 + NodeCount(T-lchild) + NodeCount(T-rchild); 递归思想写一个算法求一颗二叉树的深度，二叉树以二叉链表为储存方式 int Depth(BiTree T) if (T == NULL) return 0; int ld = Depth(T-lchild); int rd = Depth(T-rchild); return (ld rd ? ld : rd) + 1; 递归思想 相关代码/************************************** * file name : BST.c * author : 17866044205@163.com * date : 2025/11/2 * function : 用“双向不循环链表”实现 BST（二叉查找树）。 * 注：实际代码里仍然是经典二叉链，没有用到“双向”特性， * 也没有循环，名称容易误导。 * note : 该代码框架由本人所写，代码改进和注释由AI改进 * CopyRight (c) 2025 17866044205@163.com All Right Reserved ****************************************/#include stdio.h#include stdlib.h#include stdbool.h#include assert.htypedef int DataType_t;/* --------------- 节点定义 --------------- */typedef struct BSTNode DataType_t key; struct BSTNode *left; struct BSTNode *right; BSTNode;/* --------------- 内部工具：创建孤立节点 --------------- */static BSTNode *new_node(DataType_t key) BSTNode *n = (BSTNode *)calloc(1, sizeof(*n)); assert(n != NULL); /* 内存申请失败直接终止 */ n-key = key; return n;/* --------------- 对外接口：插入（可处理空树） --------------- */bool BST_insert(BSTNode **proot, DataType_t key) assert(proot != NULL); /* 调用者必须传合法指针 */ if (*proot == NULL) /* 空树场景：直接成为根 */ *proot = new_node(key); return true; BSTNode *cur = *proot; while (cur) if (key == cur-key) /* 重复键拒绝插入 */ return false; if (key cur-key) if (!cur-left) /* 找到空位，挂左子树 */ cur-left = new_node(key); return true; cur = cur-left; else if (!cur-right) /* 找到空位，挂右子树 */ cur-right = new_node(key); return true; cur = cur-right; return false; /* 不可达 *//* --------------- 中序遍历（打印） --------------- */void BST_inorder(const BSTNode *root) if (!root) return; BST_inorder(root-left); printf(%d , root-key); BST_inorder(root-right);/* --------------- 后序销毁（释放全部节点） --------------- */void BST_destroy(BSTNode *root) if (!root) return; BST_destroy(root-left); BST_destroy(root-right); free(root);/* --------------- 简单自测 --------------- */#ifdef BST_TESTint main(void) BSTNode *root = NULL; int arr[] = 50, 30, 70, 20, 40, 60, 80; for (size_t i = 0; i sizeof(arr)/sizeof(arr[0]); ++i) BST_insert(root, arr[i]); printf(InOrder : ); BST_inorder(root); /* 应该输出 20 30 40 50 60 70 80 */ putchar( ); BST_destroy(root); return 0;#endif"},{"title":"使用c语言实现顺序栈","path":"/2025/10/28/顺序栈的实现/","content":"我总结的实现顺序栈的步骤是 定结构 “顺序栈”需要使用连续内存保存元素；则结构体中需要可指向动态分配内存的*data记录栈顶下标 top 与当前容量 capacity 。 选内存策略 静态方案：定长数组（简单，但不可扩容）。 动态方案：calloc，可扩容，使用calloc必须free释放内存。 统一接口 创建、压栈、销栈、销毁。 处理“空”与“满” 空： top -1 满： top capacity-1 错误码返回值 C 语言没有异常，用 布尔Bool 返回操作成败； 打印 打印栈中的值。 代码展示#include stdio.h#include stdlib.h#include stdbool.h/*-------------------------- 类型定义 --------------------------*/typedef int ElemType; // 栈中元素类型，可一键改成其它基本类型typedef struct ElemType *data; // 动态数组，存放栈元素 int top; // 栈顶指针（指向当前栈顶元素，-1 表示空栈） int capacity; // 当前最大容量 SeqStack;/*-------------------------- 栈的创建 --------------------------*//* * 功能：创建一个空栈，可存放 size 个元素 * 返回值：栈管理结构指针，失败直接 exit */SeqStack *Stack_Create(int size) /* 1. 给管理结构本身申请内存 */ SeqStack *manager = (SeqStack *)calloc(1, sizeof(SeqStack)); if (!manager) // calloc 失败 perror(calloc); exit(EXIT_FAILURE); /* 2. 给真正存数据的数组申请内存 */ manager-data = (ElemType *)calloc(size, sizeof(ElemType)); if (!manager-data) perror(calloc); exit(EXIT_FAILURE); /* 3. 初始化成员 */ manager-top = -1; // 空栈 manager-capacity = size; // 记录容量 return manager;/*-------------------------- 入栈 --------------------------*//* * 功能：把元素 n 压栈 * 返回值：成功 true，失败 false（栈满或 manager 为空） */bool Stack_Push(SeqStack *manager, ElemType n) if (!manager) return false; /* 栈满判断：top 指向最后一个元素下标，容量为 capacity */ if (manager-top == manager-capacity - 1) printf(顺序栈已满，无法入栈 ); return false; /* 先移动栈顶指针，再写入数据 */ manager-data[++manager-top] = n; return true;/*-------------------------- 批量出栈 --------------------------*//* * 功能：连续弹出 cnt 个元素（只做逻辑删除，不返回元素值） * 返回值：成功 true，失败 false（栈空或 cnt 不合法） */bool Stack_Drop(SeqStack *manager, int cnt) if (!manager) return false; if (manager-top == -1) // 空栈 printf(顺序栈已空 ); return false; if (cnt manager-top + 1) // 请求弹出数 实际元素数 printf(弹出次数大于当前栈内元素个数 ); return false; /* 简单地把栈顶指针往下移，即完成“逻辑删除” */ for (int i = 0; i cnt; ++i) --manager-top; return true;/*-------------------------- 打印栈 --------------------------*//* * 功能：从栈顶到栈底依次打印元素 * 返回值：成功 true，失败 false */bool Stack_Print(SeqStack *manager) if (!manager) return false; for (int i = manager-top; i = 0; --i) printf(data[%d] = %d , i, manager-data[i]); return true;/*-------------------------- 销毁栈 --------------------------*//* * 功能：释放栈占用的所有内存 */void Stack_Destroy(SeqStack *manager) if (!manager) return; free(manager-data); // 先释放数组 free(manager); // 再释放管理结构/*-------------------------- 测试主函数 --------------------------*/int main(int argc, char const *argv[]) /* 1. 创建一个容量为 5 的顺序栈 */ SeqStack *s = Stack_Create(5); /* 2. 连续压入 5 个元素 */ Stack_Push(s, 10); Stack_Push(s, 20); Stack_Push(s, 30); Stack_Push(s, 40); Stack_Push(s, 50); /* 3. 打印当前栈（预期 50 40 30 20 10） */ Stack_Print(s); puts(); // 空行 /* 4. 弹出 3 个元素（只剩 20 10） */ Stack_Drop(s, 3); /* 5. 再次打印 */ Stack_Print(s); /* 6. 释放内存 */ Stack_Destroy(s); return 0; 这段代码最大的不足是“功能简陋且不安全”：它只做了最基本的固定容量栈，没有自动扩容、弹出的元素无法返回给调用者，离可复用、健壮的通用栈还差得较远，但可按照实际需要稍作修改还是能够实现顺序栈的基本功能。"},{"title":"使用c语言创建双向循环链表","path":"/2025/10/26/双向循环链表的创建/","content":"代码展示代码由本人所写，注释由AI生成仅供参考 本人学完了单向链表、单向循环链表、双向链表、双向循环链表，但个人觉得直接创建双向链表也能体现我所获得的知识，即在这个过程中本人除了写了单向链表的代码直接写双向循环链表来体现个人的积累 再次我还是推荐初学者还是认真手写一下各个链表内容，这对于自己的知识掌握还是很有作用的，也请记住在面对我们无法理解的知识，积累它总会有一天我们会弄懂的 /************************************** * file name:s2.c * author :17866044205@163.com * date :2025/10/26 * function :创建双向循环链表能够从头插入，尾插入，目标位插入包括删除也相同。 * note ：None * * CopyRig （c） 2025 17866044205@163.com All Right Reseverd * * ****************************************//* 双向循环链表 —— 完整注释版 * 编译：gcc dll_demo.c -o dll_demo */#include stdbool.h // bool 类型#include stdlib.h // calloc, free, exit, EXIT_FAILURE#include stdio.h // printf, perror, puts/* --------------- 类型定义 --------------- */typedef int DataType_t; // 数据域类型，可随意替换typedef struct Doubly_Circular_LinkedList // 链表节点 DataType_t Data; // 业务数据 struct Doubly_Circular_LinkedList *next; // 后继 struct Doubly_Circular_LinkedList *prev; // 前驱 LList_t;/* --------------- 创建空链表 --------------- *//* 返回一个带头结点的空双向循环链表。 * 头结点不存储有效数据，其 prev/next 均指向自己，表示“空”。 */LList_t *LList_create_Head(void) LList_t *Head = (LList_t *)calloc(1, sizeof(LList_t)); if (!Head) // 内存申请失败立即报错终止 perror(calloc); exit(EXIT_FAILURE); Head-prev = Head-next = Head; // 自环，空链表标志 return Head;/* --------------- 申请新节点 --------------- *//* 根据给定数据生成一个孤立节点，prev/next 先置 NULL。 */LList_t *LList_NewNode(DataType_t data) LList_t *New = (LList_t *)calloc(1, sizeof(LList_t)); if (!New) perror(calloc); exit(EXIT_FAILURE); New-Data = data; New-prev = New-next = NULL; return New;/* --------------- 头插法 --------------- *//* 把 data 插入到“第一个有效节点”之前，时间复杂度 O(1)。 */bool LList_HeadAdd(LList_t *Head, DataType_t data) if (!Head) return false; // 健壮性：空指针判断 LList_t *New = LList_NewNode(data); // 1. 造节点 if (!New) return false; /* 2. 四步插入（画图即明） */ New-next = Head-next; // 新节点连上旧首元 New-prev = Head; // 新节点连上头结点 Head-next-prev = New; // 旧首元的前驱改指新节点 Head-next = New; // 头结点后继更新为新节点 return true;/* --------------- 尾插法 --------------- *//* 把 data 追加到链表末尾，时间复杂度 O(n)（因需扫到尾）。 */bool LList_TailAdd(LList_t *Head, DataType_t data) if (!Head) return false; LList_t *New = LList_NewNode(data); /* 找到最后一个节点：其 next 指向 Head */ LList_t *cur = Head; while (cur-next != Head) cur = cur-next; /* 把 New 插到 cur 与 Head 之间 */ New-next = Head; // 新节点闭环 New-prev = cur; // 新节点前驱是旧尾 cur-next = New; // 旧尾后继更新 Head-prev = New; // 头结点前驱更新为新尾 return true;/* --------------- 按值前插 --------------- *//* 在第一个等于 Dest 的节点“后面”插入 data。 * 若 Dest 不存在则打印提示并返回 false。 */bool LList_DestAdd(LList_t *Head, DataType_t Dest, DataType_t data) if (!Head) return false; /* 从首元开始扫，直到回到头结点为止 */ LList_t *cur = Head-next; while (cur != Head cur-Data != Dest) cur = cur-next; if (cur == Head) // 扫完一圈没找到 printf(未找到目标值 ); return false; LList_t *New = LList_NewNode(data); if (!New) return false; /* 把 New 插到 cur 与 cur-next 之间 */ New-prev = cur; New-next = cur-next; cur-next-prev = New; cur-next = New; return true;/* --------------- 按值删除 --------------- *//* 删除第一个等于 Dest 的节点，成功返回 true，不存在返回 false。 */bool LList_DestDev(LList_t *Head, DataType_t Dest) if (!Head) return false; LList_t *cur = Head-next; // 从首元开始 while (cur != Head cur-Data != Dest) cur = cur-next; if (cur == Head) // 没找到 printf(未找到目标值 ); return false; /* 把 cur 从环中“摘”出来 */ cur-prev-next = cur-next; cur-next-prev = cur-prev; free(cur); // 真正释放 return true;/* --------------- 遍历打印 --------------- *//* 从头结点下一个（首元）开始，顺序打印所有有效数据。 */bool LList_Print(LList_t *Head) if (!Head) return false; LList_t *PHead = Head-next; // 首元 while (PHead != Head) // 回到头结点即停 printf(data = %d , PHead-Data); PHead = PHead-next; return true;/* --------------- 销毁整个链表 --------------- *//* 先释放所有数据节点，最后释放头结点，防止内存泄漏。 */void LList_destroy(LList_t *Head) if (!Head) return; LList_t *cur = Head-next; // 从首元开始 while (cur != Head) // 一圈扫完即止 LList_t *next = cur-next; // 提前保存后继 free(cur); // 释放当前 cur = next; free(Head); // 头结点最后释放/* --------------- 测试主函数 --------------- */int main(int argc, char const *argv[]) /* 1. 建表 */ LList_t *list = LList_create_Head(); /* 2. 尾插 30 40 50 */ LList_TailAdd(list, 30); LList_TailAdd(list, 40); LList_TailAdd(list, 50); /* 3. 头插 20 10 */ LList_HeadAdd(list, 20); LList_HeadAdd(list, 10); /* 4. 打印：预期 10 20 30 40 50 */ LList_Print(list); puts(); /* 5. 在 50 后面插入 60 */ LList_DestAdd(list, 50, 60); LList_Print(list); // 预期 10 20 30 40 50 60 puts(); /* 6. 删除 10(头) 30(中) 60(尾) */ LList_DestDev(list, 10); LList_DestDev(list, 30); LList_DestDev(list, 60); LList_Print(list); // 预期 20 40 50 puts(); /* 7. 销毁链表 */ LList_destroy(list); return 0; 个人感言双向循环链表和单向循环链表差别在于多了个前驱指针指向前一个存储块，但属于基本原理后双向循环链表并分比单向链表更加困难掌握链表只是学习过程中的第一步，总会有困难拦住你，而在我学习中也遇到了让我一度想放弃的困难，我是如何战胜它们的呢？我保持着沉默，我又去玩了一天什么都不做，然后我又回来了，继续挑战困难。这是一种感觉得自己品味才能明白，"},{"title":"计算机系统基础知识","path":"/2025/10/26/嵌入式系统设计师第一章/","content":"这是我阅读《嵌入式系统设计师》第一章所写的笔记以及知识概要，第一章讲的是计算机的基础知识，涉及的到了计算机各种器件、系统包括底层逻辑。 嵌入式计算机系统概述计算机硬件嵌入式计算机是以应用为中心，以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。 计算机硬件系统由运算器、控制器、储存器、输入设备、输出设备组成。 运算器和控制器以及相关部件集成一起称为中央处理单元：cpu。 运算器：对数据进行加工处理。 控制器：从主存取出指令进行分析。 储存器：分为内存（掉电丢失）、外存（掉电不丢失）。寄存器是cpu中的储存器件（储存少量数据，读取速度更快。） 数据表示进制转换 效验码 奇偶校验码 海明码在数据之间的特定位置插入k个校验位，通过扩大码距实现验错和纠错。 异或运算计算方式 算数运算计算机使用加法运算器，将两个数的补码相加。加上一个负数时，二进制数超过八位则自然丢弃。 溢出及判定两个补码相加时有可能会向第八位进1，但第八位是符号位，俩正数相加不可能得出负数。双符号位判决法、进位判决法 计算机组成及主要部件CPU的功能：程序控制、操作控制、时间控制、数据处理。CPU还会对系统内部和外部的中断（异常）做出响应。CPU构造图 运算器：算术逻辑单元、累加寄存器、数据缓存寄存器、状态条件寄存器组成。 控制器发出信号控制运算器。运算器不会自己产生程序。 算术逻辑单元（ALU）：处理数据对进行算术和逻辑运算。 累加寄存器（AC）：ALU的工作区“默认操作数和结果暂存桌”，减少CPU多次访问内存。 数据缓冲寄存器（DR）：暂时作为CPU与内存、外部设备数据传输之间的中转站，只能存一条指令或一个数据字。 状态条件寄存器（PSW）：存结果为零有进位溢出的状态，让 CPU 知道下一步该不该跳转。 控制器：指令控制逻辑、时序控制逻辑、中断控制逻辑。 指令控制逻辑：取指令、分析指令、执行指令。 指令寄存器（IR）：CPU将要执行的指令，从内存到数据缓冲寄存器，再到IR暂存，由指令译码器根据IR的内容产生各种微操作的指令，控制其他组件。 程序计数器（PC）：寄存信息和计数。 地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。 指令译码器（ID）：指令包含操作码和地址码，ID对操作码进行分析，识别该指令的规定操作。 时序控制逻辑：为每条指令按时间提供控制信息。总线逻辑是为多个功能部件服务信息通路的控制电路。中断控制逻辑用于控制各种中断请求，并根据优先级的高低对中断请求进行排队。 运算器和控制器中的寄存器都是专用寄存器。 储存器高速缓存Cache（容量小，贵，掉电丢失）：储存内存中CPU可能需要的数据，加快CPU运行时间。Cache地址影像为主存中CPU需要的数据提前找好座位。直接映像：主存中和Cache中的块对应关系是固定的。全相联映像：主存中任何一块数据都能放进Cache中的任意一个空位。组相联映像：分组时直接映像，组内全相联映像。虚拟储存器：对主存的抽象，MMU实现虚拟地址到物理地址的转换。外存储器：磁盘、光盘、固态。储存域网络：连接服务器与储存设备的网络。 总线计算机中的总线是指计算机设备和设备之间传输信息的公共数据通道。数据总线：双向传输数据。地址总线：单向传递CPU发出的地址信息。地址总线的宽度决定CPU的最大寻址能力控制总线：传输控制信号、时序信号、状态信号 南北桥芯片结构北桥芯片直接与CPU（通过前端总线）、内存（内存总线）、显卡（IO总线）、南桥相连，控制CPU的类型、主板的总线频率、内存控制器、显示核心等。南桥芯片：负责外部设备接口与内部CPU的联系（IO总线），如USB、ATA、SATA以及扩展接口。（包含多种设备的控制器、硬盘控制器、USB控制器、网卡、声卡控制器） 单芯片结构取消了北桥，CPU内置内存控制器，提高频率减少延迟。 常见总线ISA总线、EISA总线、PCI总线（其工作与CPU相互独立，PCI总线时钟与CPU时钟也是相互独立，PCI总线上的设备可以申请成为主控设备，与从属设备进行点对点的数据传输。还能对传输的地址和信号进行奇偶校验检测。 输入输出控制IO设备：电子芯片、导线、电源、电子控制设备、电机等组成的物理设备。 IO设备可分为块设备（将信息存放于独立的块中，可寻址，包括磁盘、USB闪存等）、字符设备（以字符为单位接收或发送一个字符串，不可寻址，包括打印机、网卡、鼠标键盘等） 设备控制器都有几个寄存器与CPU进行通信（通过寄存器发送或接收数据，和了解设备的状态）寄存器数量和大小有限，一般会RAM性质的缓冲区来存放数据。 RAM（随机存储器、主存、内存）：断电丢失数据、高速存取、随机访问、临时存储。 CPU如何与设备控制器中寄存器和数据缓冲区进行通信：1.\t为每个控制器分配一个IO端口，形成端口空间，并将信息储存于内存，由操作系统通过特殊指令和端口号来访问设备读取或是写入数据。2.\t将控制器的寄存器映射到内存空间，每个设备都有唯一的地址——内存映射IO。不需要特殊指令控制，可以使用C语言来编程。 程序控制方式无条件传送：外设无条件向CPU接收或发送数据。程序查询方式：通过CPU执行程序来查询外设的状态。 中断方式多中断信号线法：每个中断源都有属于自己的一根中断请求向CPU提供中断请求。 中断软件查询法：当CPU检测到了中断请求，立即转入中断服务程序去轮询每个中断源确实来源，对各个设备的相应由软件设定。 菊花链法：硬件查询法，所有IO模块共有一根共同的中断请求线，中断确认信号以链式在各个模块间相连，当CPU检测到中断请求信号时，则发出中断确认信号，中断确认信号依次在IO模块中传递，知道发出请求的模块，该模块把它的ID送往数据线由CPU读取。 总线仲裁法：一个IO设备在发出中断请求前，必须获得总线控制权，由总线仲裁来裁定谁可以发出中断请求信号，当CPU发出中断响应信号后该设备立即把自己的ID发往数据线。 DMA方式直接内存存取数据在内存与IO设备之间的直接成块传送，传输数据过程中不需要CPU干涉，CPU只需要发出开始或结束。DMA传送过程中，整个系统总线完全交给了DMAC，CPU不再使用总线。 输入输出处理机DMA出现方式减轻了CPU对IO操作的控制，使CPU效率提高。通道是是一个具有特殊功能的处理器，它分担一部分CPU功能，可以实现对外围设备的统一管理，完成外围设备与主存之间的数据传送。外围处理机，PPU是专用处理机，根据主机IO命令。完成对外设数据的输入输出 计算机体系结构计算机体系结构概述阿姆达尔：程序员要能编写出可以在机器上正确运行的程序必须了解概念性结构和功能特性。 梅尔斯：硬件与软件之间的界面，指令集体结构。 拜尔：体系结构由：结构（硬件互连）、组织（各种部件的动态联系与管理）、实现（各模块设计的组装完成）、性能（计算机系统的行为表现）。 计算机体系结构：计算机的概念性结构和功能特性。 计算机组织：计算机体系结构的逻辑实现，包括计算机内的数据流和控制流的组成以及逻辑设计。 计算机实现：计算机组织的物理实现。 计算机体系结构分类宏观：单处理系统、并行处理系统、多处理系统、分布式处理系统。 单处理系统：利用一个处理单元与外部设备结合实现储存、计算、通信、输入与输出等功能。 并行处理系统与多处理系统：将两个以上的处理器连接，协调通信，共同求解问题的计算机系统。 分布式处理系统：物理距离上远距离松耦合的多计算机系统。 微观（并行程度分类）：Flynn分类法、冯泽云分类法、Handler分类法、Kuck分类法 Flynn分类法：按指令流和数据流进行分类。单指令流、单数据流；单指令流、多数据流；多指令流、单数据流；多指令流、多数据流。 冯泽云分类法：按并行度（单位时间内处理的最大二进制位数）对计算机的系统进行结构分类。字串行位串行、字并行位串行、字串行位并行、字并行位并行 Handler分类法：基于硬件并行程度计算并行度的方法。 Kuck分类法：用指令流和执行流及其多重要性。类似于Flynn分类法 指令系统指令集体系结构：一个处理器支持的指令和指令的字节级编程。（不同处理器往往不通用） 指令集体系结构分类根据：操作数在CPU上的储存方式、显示操作数的数量、操作数的位置、指令的操作、操作数的类型与大小。 按暂存机制分类可将指令集体系分为：堆栈、累加器、寄存器组。 通用寄存器：寄存器提供更灵活的次序，能够储存变量。 CISC和RISC复杂指令集计算机（CISC）：增强原有指令的功能，用更复杂的新指令替换原先由软件程序完成的功能。 弊端：1.\t指令集过于庞杂。2.\t需要用多个CPU周期运行解释性微程序来执行复杂指令。3.\t高级语言编程程序选择目标指令范围很大，难以优化。4.\tCISC强调完善的中断控制，导致动作繁多、设计复杂、研制周期长。5.\tCISC增大芯片种类、出错率提高，成品率降低，成本提高。 精简指令集（RISC）：减少指令总数和简化指令功能、降低硬件设计复杂度，优化编译提高指令执行速度，采用硬布线控制逻辑优化编译程序。 RISC关键技术：1.\t重叠寄存器窗口技术：在处理器中设置数量较大的寄存器堆。2.\t优化编译技术：RISC使用大量寄存器，通过编译技术的优化来实现合理分配寄存器，提高寄存器的效率减少访存次数。3.\t超流水及超标量技术：进一步提高流水线速度。4.\t硬布线逻辑和微程序相结合在微程序技术中。 优化静态使用频率：对程序中出现的各种指令以及指令串进行统计得到的百分比。 按静态使用频率来改进目标代码，可减少程序所占的储存空间。 动态使用频率：在程序执行过程中各种指令以及指令串进行统计得到的百分比。 按动态是使用频率来改进目标代码，可减少程序运行的执行时间。 面向高级程序语言的优化思路是减少高级语言与机器语言之间的语义差距。 面向操作系统的优化思路是减少操作系统与体系结构之间的语义差距。 指令的流水处理指令控制方式：顺序方式、重叠方式、流水方式。 顺序方式：各条机器指令包括内部微操作按顺序串行执行，缺点速度慢、机器各部件利用率低。 重叠方式：在执行第K条指令就开始分析第K+1条指令。速度提高、易冲突。 流水方式：并行性或并发性嵌入计算机的一种形式。将重复的顺序处理过程分解为若干字过程，每个字过程都能在专用模块上有效的并发工作。 如分为取指令、指令译码、取操作数、执行，将机器指令并发在这几种模块上处理。1.\t级别：部件级、处理机级、系统级。2.\t功能：单功能流水、多功能流水。3.\t连接：静态流水线、多功能流水线。4.\t反馈回路：线性流水线、非线性流水线。5.\t流动顺序：同步流水线、异步流水线。6.\t数据：标量流水线、向量流水线。 流水的相关处理：对同一寄存器先写后读会出现指令相关、访存操作数相关、通用寄存组相关等，影响相关的两条或几条指令，也被称为局部相关。 推后法：推后相关单元的读，直至写入完成。 通路法：设置相关专用通路，先把运算结果写入相关储存单元。 全局性相关：不能同时解释转移指令，执行转移指令，可能会改变指令缓冲器中预取到指令内容，造成流水线的吞吐率（单位时间内流水线处理机流出的结果数）和效率下降。 猜测转移分支、加快和提前形成条件码、加快短循环程序的处理 RISC采用的流水技术超流水线：增加级数提高主频，以时间换空间。CPI（指令需要的机器周期数稍高。超标量技术：内装多条流水线同时执行多个处理，以空间换时间。超长指令字技术：充分发挥软件作用，使硬件简化，性能提高，需要足够高的时钟频率 阵列处理机、并行处理机、多处理机 可靠性与系统性能评测基础知识元器件可靠性的三个阶段开始阶段：不稳定失效率较高。第二阶段：正常工作期。第三阶段：老化期 计算机的可用性用正常工作的概率A表示 两次故障之间系统能正常工作时间的平均值MTBF 计算机的可维修性平均维修时间MTRF AMTBFMTBF+MTRF 计算机的RAS：可靠性R、可用性A、可维修性S 计算机可靠性模型 N模冗余系统：由N个（2n+1）相同的子系统和一个表决器组成，以N个系统中的多数输出作为系统输出. 提高计算机的可靠性1.\t提高元器件质量，改进加工工艺与工艺结构，完善电路设计。2.\t发展容错技术，使计算机在有故障的情况下依旧能工作。 计算机系统的性能评价性能评测的常用方法：时钟频率、指令执行速度、等效指令速度法、数据处理速率、核心程序法。 准测试程序整数测试程序：测试编译器、CPU处理整数指令、控制功能的有效性。 浮点测试程序：测试浮点计算能力。 1.理论峰值浮点速度（MFLOPS）：测试机器在理论上最大能完成的浮点计算速度。 2.Linpack基准测试程序：让机器运行Linpack程序来测量MFLOPS。 3.Whetstone基准测试程序：执行浮点运算、整数算术运算、功能调用、数组变址、条件转移和超越函数的程序组成。 SPEC基准程序：被测计算机的执行时间标准化，被测计算机的执行时间除以一个参考处理器的执行时间。 TPC基准程序：衡量机器性能以及性能价格比。"},{"title":"C语言核心内容总结","path":"/2025/10/25/C语言核心内容总结/","content":"距离学完C语言核心内容已过半月、是时候总结一下我的学习成果了，在过去的半月中、曾一度面对困难想要逃避放弃，但积累的成果告诉我，我已经做了这么多了，那些曾经棘手的问题都已经转换成了我积累的一部分了。 C语言核心内容笔记 核心关键字32 个关键字auto break case char const continue default dodouble else enum extern float for goto ifint long register return short signed sizeof staticstruct switch typedef union unsigned void volatile while 第一档 ：int 整型类型关键字，声明整数变量、函数返回值。return 函数返回语句，结束函数并带回结果。if （else） 条件判断for 计数循环最常用。while 条件循环。break 跳出当前循环或switch。continue 跳过本轮循环剩余语句。switch 多路分支。case switch 的分支标签。default 处理switch中为被case标签匹配的情况。void “空”类型，函数不返回值或指针不带类型。sizeof 编译期求类型对象字节数 第二档：char 字符／最小整数类型。float 单精度浮点。double 双精度浮点。long 加长整型short 短整型。signed unsigned 有符号／无符号修饰符。const 只读修饰符，编译期阻止修改。static 两种用法： 1. 函数内部——静态存储期，只初始化一次。 2. 函数文件外部——内部链接，只对当前文件可见。extern 声明标识符“定义在别处”，跨文件引用全局变量函数。struct 结构体，聚合类型之王。union 联合体，同一内存 overlay 多种类型。enum 枚举，给整型常量起名字。typedef 给已有类型起新名字，造“别名”。volatile 告诉编译器“该对象可能异步改变”，禁止优化。 第三档auto 函数内局部变量默认就是 auto，写不写都一样。do do{…}while(); 循环，至少执行一次。goto 无条件跳转，能不用就不用。register 建议编译器把变量放寄存器，现代编译器基本忽略。 内存管理学习c语言一定要联系计算机背后的运行逻辑，而其与计算机中的内存管理最为重要 保留区作用捕获“空指针解引用”和“小偏移量野指针”为内核 vsyscall、vsyscall32、vdso 等保留固定映射页属性：不可访问 代码段内容： – 所写的函数体、编译器生成的辅助函数。 – 模块初始化函数（**init）在 Linux 内核被收集到 .init.text，启动完后内核会把这块回收。属性：可读可执行，不可写。生命周期：随进程一直存在；内核模块的 .init.text 在初始化结束被 free_init_pages() 释放。 数据段rodata编译器把字符串、跳转表等单独放进 .rodata，只读数据段防止映射成可执行页。内容：字符串字面量、const 全局变量、switch 跳转表、printk 的格式串…… 已初始化数据段Data内容： – 全局变量、文件作用域变量、static 局部变量，且你在源码里给了初值。 – 内核的 **initdata，启动后同样会被回收。属性：可读可写，不可执行。 未初始化数据段BSS内容：全局static 变量未显式赋初值（或初值为 0）属性：可读可写，不可执行。 堆内容：malloccallocnew、realloc、free 管理的对象；内核的 kmalloc(vmalloc) 区。增长方向：向高地址伸展。属性：可读可写，可执行堆需显示（高危操作）。生命周期：程序员显式释放或进程退出时内核统一回收。 栈内容： – 函数调用的返回地址、参数、局部变量、寄存器保存区。 – 编译器生成的临时数组、VLAs、alloca()。内容：增长方向：向低地址生长属性：可读可写，不可执行。生命周期：线程创建时分配，线程退出时回收；主线程随进程一起消失。 动态内存管理malloc、calloc都是向“堆（heap）”申请一块连续内存的标准库函数，不会被自动回收，需要手动释放。本身属于 libc 的 text（代码段）；它们返回的那块空间才属于 heap（堆）。 #include stdlib.hvoid *malloc(size_t size); // 申请 size 字节，内容不确定void *calloc(number, size_t size); // 申请 number 块，每块size字节 ，全部清 0//返回值：成功返回指向首字节的 void * ，失败返回 NULL 。所以必须做 NULL 检查！ calloc与malloc的优缺点：1.calloc 内部会检测 number*size 是否溢出；而 malloc 不会，使用malloc必须做溢出处理。2.申请大块内存 calloc会把每一页刷成 0，所以比malloc慢。如果随后需要自己再写一遍，不如直接 malloc +手动赋初值。3.无论是 malloc 还是 calloc ，都必须用 free(ptr) 释放一次且仅一次。 memsetmemset 是 C 标准库 string.h 里最常用的“内存填充”工具函数把从地址a开始的n个字节，全部设置为同一个字节值b。 #include string.hvoid *memset(void *a, int b, size_t n); memset的典型用法1.清零 int a[100];memset(a, 0, sizeof a); // 整个数组变 0 2.置1字节 unsigned char buf[64];memset(buf, 0xFF, sizeof buf); // 每个字节 0xFF 3.初始化为某个字节 char str[32];memset(str, *, sizeof str - 1);/* 31 个 * */str[31] = \\0; // 手动补字符串结束符 、 错误处理防御性编程定义：种主动预防错误的编程策略，强调在代码中提前识别并处理潜在问题，避免因外部输入、异常状态或并发操作导致系统崩溃核心假设 ：输入总是错误的- 外部依赖不可靠- 代码本身可能有 bug目标 ：提高系统的健壮性、可维护性、容错能力，降低故障蔓延风险。 Segmentation（段错误） 根本原因：访问了无权或无效的虚拟地址1.解印引用NULL2.野指针悬垂指针3.越界访问4.缓冲区溢出覆盖返回地址5.对字符串常量区写入6.函数返回局部变量地址 总结学习c语言没有完成时，只有提高我们的逻辑思维不断的增加c语言相关知识，才能够编程出更精简更出色的代码。学习了c语言的知识就该知道如何使用它们，在使用的过程中接触新的内容，融会贯通，才能在编程的道路上越走越。"},{"title":"使用c语言创建顺序表","path":"/2025/10/22/顺序表的创建/","content":"本篇文章是我学习数据结构过程中，共花费4个小时实现顺序表创建的c语言代码，学完c语言后第一次完全由自己从零到一写完代码的过程，在学习过程中总会遇到当前阶段难以挑战的困难，我也在学习数据结构的过程中几次逃避，但是‘积累’给我带来面对挑战的勇气，长期的积累就是我不服输的底气。 代码展示// 引入3个头文件：布尔类型、通用工具、标准输入输出#include stdbool.h#include stdlib.h#include stdio.htypedef int DataType_t; //可替换数据类型/* 顺序表结构体定义 */typedef struct SequenceList int * Addr; // 指向真正存放数据的动态数组 unsigned int MaxSize; // 数组最大容量 int Last; // 当前最后一个元素的下标（空表时为-1） SeqList_t;/* 创建一个容量为size的顺序表，返回管理体指针 */SeqList_t * SeqList_Create(unsigned DataType_t size) // 给管理体本身申请一块清零的内存 SeqList_t *Manager = (SeqList_t *)calloc(1, sizeof(SeqList_t)); if (NULL == Manager) // 管理体内存申请失败 printf(为管理体分配内存失败 ); exit(-1); // 直接终止整个程序 if (0 = size) // 容量不合法 printf(创建的顺序表尺寸不能小于1 ); exit(-1); // 给数据区申请size个int的清零空间 Manager-Addr = (DataType_t *)calloc(size, sizeof(int)); if (NULL == Manager-Addr) // 数据区内存申请失败 printf(为管理体指向Addr的储存区分配内存失败 ); free(Manager); // 先释放已申请的管理体 exit(-1); Manager-MaxSize = size; // 记录最大容量 Manager-Last = -1; // 初始为空表 return Manager; // 返回管理体指针/* 判断顺序表是否已满 */bool SeqList_IsFull(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last + 1 == Manager-MaxSize); // 满返回true，否则false/* 判断顺序表是否为空 */bool SeqList_IsEmpty(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last == -1); // Last为-1表示空表/* 头插：把data插入到表头（下标0位置） */bool SeqList_HeadAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; // 把原有元素整体后移一位 for (int i = Manager-Last; i = 0; --i) Manager-Addr[i + 1] = Manager-Addr[i]; Manager-Addr[0] = data; // 新元素放入头部 Manager-Last++; // 更新Last return true;/* 尾插：把data追加到表尾 */bool SeqList_TailAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; Manager-Addr[++Manager-Last] = data; // 先Last+1，再写入数据 return true;/* 按值删除：删除第一个等于data的元素 */bool SeqList_Del(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表无法删除 printf(顺序表为空，无法删除 ); return false; int i = 0; // 找到第一个等于data的元素下标 while (Manager-Addr[i] != data i = Manager-Last) i++; if (i = Manager-Last) // 找到了 // 把后面元素整体前移一位覆盖掉被删元素 while (i Manager-Last) Manager-Addr[i] = Manager-Addr[i + 1]; i++; Manager-Last--; // 元素个数减1 return true; // 没找到 printf(此顺序表中没有找到你指定要删除的数 ); return false;/* 打印整个顺序表 */bool SeqList_Print(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表提示 printf(元素为空无法打印 ); return false; // 逐个元素打印 for (int i = 0; i = Manager-Last; ++i) printf(Addr[%d]=%d , i, Manager-Addr[i]); return true;/* 销毁顺序表：先释放数据区，再释放管理体 */void SeqList_Destroy(SeqList_t *Manager) if (!Manager) return; // 空指针直接返回 free(Manager-Addr); // 释放数据区 free(Manager); // 释放管理体/* 主函数：简单测试 */int main(int argc, char const *argv[]) // 创建一个容量为5的顺序表 SeqList_t *list = SeqList_Create(5); // 尾插5个元素 SeqList_TailAdd(list, 10); SeqList_TailAdd(list, 20); SeqList_TailAdd(list, 30); SeqList_TailAdd(list, 40); SeqList_TailAdd(list, 50); SeqList_Print(list); // 打印当前表 printf( ); // 删除3个元素 SeqList_Del(list, 10); SeqList_Del(list, 30); SeqList_Del(list, 50); SeqList_Print(list); // 再次打印 SeqList_Destroy(list); // 用完销毁 return 0; 当然作为一个初学者我所写的代码还存在着可以优化的地方，但从逻辑上来分析我所写代码的优势就在于逻辑清晰。放在学生作业、嵌入式底层库中、面试笔试场景中都有不少亮点。 代码优势1.结构设计： 我将管理元数据与数据区彻底分离。2.接口语义清晰： 我大部分函数都使用的bool返回，失败false、成功true，语义单一。3.可裁剪性高： 没有任何全局变量静态变量。4.精确的错误信息： 每条错误都带由中文提示。5.空指针的保护密度： 每个接口都做了 if (!Manager) return false;。6.初始化策略： 选择使用calloc，使用malloc需要手动添加memset。7.数据类型： 可以更改数据类型，提高了泛型能力。 代码缺点 内存申请失败直接 exit，把库变成了进程杀手，嵌入式或插件场景根本没法优雅降级。 容量固定，没有扩容接口，浪费内存。 头插和删除用循环搬数据，O(n) 最坏复杂度。 按值删除只清掉第一个匹配项，想全删得外层再套循环，时间平方级。 只有头插尾插，没有按位置插入，用户想往中间放元素只能自己拼“删了再插”的野路子，还是 O(n²)。 没有 FindIndexOf 这类只读定位，判断存在性只能裸翻内存或打印人肉搜索，封装性被击穿。"},{"title":"2025年9月-10月总结","path":"/2025/10/18/2025年9月-10月总结/","content":"这是我2025年至2026年的规划，截至至2025年10月18日我已经学完了c语言，预计至10月25日学完嵌入式该具备的数据结构知识。为应对软件考试：嵌入式系统设计师，我也在阅读《嵌入式系统设计师教程》，预计明年报考。 c语言部分笔记展示 阅读《嵌入式系统设计师教程》部分笔记 深入学习了计算机的基础知识，计算机的包括组成结构，运行逻辑以及原理。对计算机的重要部件进行了研究。 数据结构部分笔记展示 数据结构与c语言紧密结合，既有对c语言代码运行的底层逻辑，对程序运行中涉及到的各个器件、内存都必须要有深刻的了解。 总结 这是我的第一篇博客，今后我会将我的各个阶段的总结、成果、笔记上传至此博客，既是对我个人的积累，也是希望我所分享的内容能为他人带来帮助。"}]