[{"title":"使用c语言创建顺序表","path":"/2025/10/22/顺序表的创建/","content":"本篇文章是我学习数据结构过程中，共花费4个小时实现顺序表创建的c语言代码，学完c语言后第一次完全由自己从零到一写完代码的过程，在学习过程中总会遇到当前阶段难以挑战的困难，我也在学习数据结构的过程中几次逃避，但是‘积累’给我带来面对挑战的勇气，长期的积累就是我不服输的底气。 代码展示// 引入3个头文件：布尔类型、通用工具、标准输入输出#include stdbool.h#include stdlib.h#include stdio.htypedef int DataType_t; //可替换数据类型/* 顺序表结构体定义 */typedef struct SequenceList int * Addr; // 指向真正存放数据的动态数组 unsigned int MaxSize; // 数组最大容量 int Last; // 当前最后一个元素的下标（空表时为-1） SeqList_t;/* 创建一个容量为size的顺序表，返回管理体指针 */SeqList_t * SeqList_Create(unsigned DataType_t size) // 给管理体本身申请一块清零的内存 SeqList_t *Manager = (SeqList_t *)calloc(1, sizeof(SeqList_t)); if (NULL == Manager) // 管理体内存申请失败 printf(为管理体分配内存失败 ); exit(-1); // 直接终止整个程序 if (0 = size) // 容量不合法 printf(创建的顺序表尺寸不能小于1 ); exit(-1); // 给数据区申请size个int的清零空间 Manager-Addr = (DataType_t *)calloc(size, sizeof(int)); if (NULL == Manager-Addr) // 数据区内存申请失败 printf(为管理体指向Addr的储存区分配内存失败 ); free(Manager); // 先释放已申请的管理体 exit(-1); Manager-MaxSize = size; // 记录最大容量 Manager-Last = -1; // 初始为空表 return Manager; // 返回管理体指针/* 判断顺序表是否已满 */bool SeqList_IsFull(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last + 1 == Manager-MaxSize); // 满返回true，否则false/* 判断顺序表是否为空 */bool SeqList_IsEmpty(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 return (Manager-Last == -1); // Last为-1表示空表/* 头插：把data插入到表头（下标0位置） */bool SeqList_HeadAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; // 把原有元素整体后移一位 for (int i = Manager-Last; i = 0; --i) Manager-Addr[i + 1] = Manager-Addr[i]; Manager-Addr[0] = data; // 新元素放入头部 Manager-Last++; // 更新Last return true;/* 尾插：把data追加到表尾 */bool SeqList_TailAdd(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsFull(Manager)) // 表满无法插入 printf(顺序表已满无法插入元素 ); return false; Manager-Addr[++Manager-Last] = data; // 先Last+1，再写入数据 return true;/* 按值删除：删除第一个等于data的元素 */bool SeqList_Del(SeqList_t *Manager, DataType_t data) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表无法删除 printf(顺序表为空，无法删除 ); return false; int i = 0; // 找到第一个等于data的元素下标 while (Manager-Addr[i] != data i = Manager-Last) i++; if (i = Manager-Last) // 找到了 // 把后面元素整体前移一位覆盖掉被删元素 while (i Manager-Last) Manager-Addr[i] = Manager-Addr[i + 1]; i++; Manager-Last--; // 元素个数减1 return true; // 没找到 printf(此顺序表中没有找到你指定要删除的数 ); return false;/* 打印整个顺序表 */bool SeqList_Print(SeqList_t *Manager) if (!Manager) return false; // 空指针保护 if (SeqList_IsEmpty(Manager)) // 空表提示 printf(元素为空无法打印 ); return false; // 逐个元素打印 for (int i = 0; i = Manager-Last; ++i) printf(Addr[%d]=%d , i, Manager-Addr[i]); return true;/* 销毁顺序表：先释放数据区，再释放管理体 */void SeqList_Destroy(SeqList_t *Manager) if (!Manager) return; // 空指针直接返回 free(Manager-Addr); // 释放数据区 free(Manager); // 释放管理体/* 主函数：简单测试 */int main(int argc, char const *argv[]) // 创建一个容量为5的顺序表 SeqList_t *list = SeqList_Create(5); // 尾插5个元素 SeqList_TailAdd(list, 10); SeqList_TailAdd(list, 20); SeqList_TailAdd(list, 30); SeqList_TailAdd(list, 40); SeqList_TailAdd(list, 50); SeqList_Print(list); // 打印当前表 printf( ); // 删除3个元素 SeqList_Del(list, 10); SeqList_Del(list, 30); SeqList_Del(list, 50); SeqList_Print(list); // 再次打印 SeqList_Destroy(list); // 用完销毁 return 0; 当然作为一个初学者我所写的代码还存在着可以优化的地方，但从逻辑上来分析我所写代码的优势就在于逻辑清晰。放在学生作业、嵌入式底层库中、面试笔试场景中都有不少亮点。 代码优势1.结构设计： 我将管理元数据与数据区彻底分离。2.接口语义清晰： 我大部分函数都使用的bool返回，失败false、成功true，语义单一。3.可裁剪性高： 没有任何全局变量静态变量。4.精确的错误信息： 每条错误都带由中文提示。5.空指针的保护密度： 每个接口都做了 if (!Manager) return false;。6.初始化策略： 选择使用calloc，使用malloc需要手动添加memset。7.数据类型： 可以更改数据类型，提高了泛型能力。 代码缺点 内存申请失败直接 exit，把库变成了进程杀手，嵌入式或插件场景根本没法优雅降级。 容量固定，没有扩容接口，浪费内存。 头插和删除用循环搬数据，O(n) 最坏复杂度。 按值删除只清掉第一个匹配项，想全删得外层再套循环，时间平方级。 只有头插尾插，没有按位置插入，用户想往中间放元素只能自己拼“删了再插”的野路子，还是 O(n²)。 没有 FindIndexOf 这类只读定位，判断存在性只能裸翻内存或打印人肉搜索，封装性被击穿。"},{"title":"2025年9月-10月总结","path":"/2025/10/18/2025年9月-10月总结/","content":"这是我2025年至2026年的规划，截至至2025年10月18日我已经学完了c语言，预计至10月25日学完嵌入式该具备的数据结构知识。为应对软件考试：嵌入式系统设计师，我也在阅读《嵌入式系统设计师教程》，预计明年报考。 c语言部分笔记展示 阅读《嵌入式系统设计师教程》部分笔记 深入学习了计算机的基础知识，计算机的包括组成结构，运行逻辑以及原理。对计算机的重要部件进行了研究。 数据结构部分笔记展示 数据结构与c语言紧密结合，既有对c语言代码运行的底层逻辑，对程序运行中涉及到的各个器件、内存都必须要有深刻的了解。 总结 这是我的第一篇博客，今后我会将我的各个阶段的总结、成果、笔记上传至此博客，既是对我个人的积累，也是希望我所分享的内容能为他人带来帮助。"}]